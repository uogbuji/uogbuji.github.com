<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
    <title>4Suite Core: Open-source Library for XML Processing</title>
    <meta content="This document describes how to perform a set of XML manipulation tasks with the 4Suite XML processing library. These tasks include parsing XML using either DOM-like or SAX-like models, querying XML or XML models using XPath, using XSLT, using XUpdate, and validating documents with RELAX NG." name="description">
    <link href="docbook_html.css" type="text/css" rel="stylesheet">
  </head>
  <body>
    <div class="article">
      <div class="article-title">
        <h1 class="title">4Suite Core: Open-source Library for XML Processing
          <br><span class="subtitle">Users' Manual</span></h1>
      </div>
      <div class="header">
        <dl>
          <dt>This version:</dt>
          <dd>Revision 0.8 (2006-08-15)</dd>
          <dt>Contributors: </dt>
          <dd><span class="author"><span class="firstname">Mike</span> <span class="othername">J.</span> <span class="surname">Brown</span> <tt class="email">&lt;mike at skew.org&gt;</tt></span></dd>
          <dd><span class="author"><span class="firstname">John</span> <span class="othername">L.</span> <span class="surname">Clark</span> <tt class="email">&lt;<a href="mailto:jlc6%40po.cwru.edu">jlc6&#64;po.cwru.edu</a>&gt;</tt></span></dd>
          <dd><span class="author"><span class="firstname">Uche</span> <span class="othername">G.</span> <span class="surname">Ogbuji</span> <tt class="email">&lt;<a href="mailto:uche.ogbuji%40fourthought.com">uche.ogbuji&#64;fourthought.com</a>&gt;</tt></span></dd>
          <dd><span class="author"><span class="firstname">Luis</span> <span class="othername">Miguel</span> <span class="surname">Morillas</span> <tt class="email">&lt;<a href="mailto:morillas%40posta.unizar.es">morillas&#64;posta.unizar.es</a>&gt;</tt></span></dd>
          <dd><span class="author"><span class="firstname">Dave</span> <span class="surname">Pawson</span> <tt class="email">&lt;<a href="mailto:dave.pawson%40gmail.com">dave.pawson&#64;gmail.com</a>&gt;</tt></span></dd>
          <dd><span class="author"><span class="firstname">Uche</span> <span class="surname">Ogbuji</span> <tt class="email">&lt;<a href="mailto:uche.ogbuji%40fourthought.com">uche.ogbuji&#64;fourthought.com</a>&gt;</tt></span></dd>
        </dl>
        <div class="abstract">
          <h2>Abstract</h2>
          <p>This document describes how to perform a set of XML manipulation
      tasks with the 4Suite XML processing library. These tasks include
      parsing XML using either DOM-like or SAX-like models, querying XML or
      XML models using XPath, using XSLT, using XUpdate, and validating
      documents with RELAX NG.</p>
        </div>
      </div>
      <hr>
      <div class="toc">
        <h2>Table Of Contents</h2>
        <p style="display: inline; padding-left: 1em">1 <a href="#id3059709548L">Introduction</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">2 <a href="#id3059670572L">Installation</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">3 <a href="#domlette">DOM-like XML processing</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.1 <a href="#id3059835948L">Parsing XML documents</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.1 <a href="#quick_reader_access">Quick access to the Domlette reader API</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.2 <a href="#full_domlette_reader">The full Domlette reader API</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.3 <a href="#base_URIs">The importance of base URIs</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.4 <a href="#id3059860268L">Parsing XML that's already a Unicode string</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.5 <a href="#NonvalidatingReader">NonvalidatingReader</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.6 <a href="#id3059861676L">EntityReader Examples</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.7 <a href="#id3059862252L">ValidatingReader</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.8 <a href="#id3059862956L">NoExtDtdReader</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.9 <a href="#id3059691116L">Creating your own reader instance</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.10 <a href="#InputSources">InputSource objects</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.1.11 <a href="#converting_DOM">Converting from other DOM libraries</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.2 <a href="#domlette_API">Domlette API summary</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">3.2.1 <a href="#id3057681324L">What about
      getElementsByTagName()?</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.3 <a href="#domlette_serializing">Serializing Domlette nodes</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.4 <a href="#id3057682540L">Building a DOM from scratch</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.5 <a href="#xpath_query">XPath query</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.6 <a href="#id3057693420L">More on base URIs</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">3.7 <a href="#id3057693932L">Why does Domlette diverge from the DOM specification?</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">4 <a href="#saxlette">SAX</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.1 <a href="#id3057695084L">Validating a document while parsing it using SAX</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.2 <a href="#saxlette_domwalker">Walking a DOM to fire SAX events</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.3 <a href="#saxlette_dombuilder">Building a Domlette from SAX events</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.4 <a href="#saxlette_generator">Feeding a generator from SAX events</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.5 <a href="#id3057696684L">SAX filters</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">4.6 <a href="#id3057705900L">Streaming canonicalization</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">5 <a href="#xpath_engine">XPath queries</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">5.1 <a href="#xpath_quick">The quickest option</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">5.2 <a href="#typeMap">Type mappings</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">5.3 <a href="#id3057708396L">Advanced use</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">5.4 <a href="#id3057722476L">Reusing parsed XPath queries</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">5.5 <a href="#id3057722860L">Migration from PyXML's XPath</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">6 <a href="#xslt_engine">XSLT processing</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.1 <a href="#simple_xslt_api">The super-simple XSLT API</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.2 <a href="#full_XSLT_API">Full XSLT processing API</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.3 <a href="#id3057731820L">Example</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.4 <a href="#id3057732332L">Using Domlette objects instead of InputSources</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.5 <a href="#id3057733356L">Top-level parameters</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.6 <a href="#id3057738092L">Using xml-stylesheet processing instructions</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.7 <a href="#id3057739884L">Alternative output destinations</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.8 <a href="#id3057751212L">Transform chaining</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">6.9 <a href="#id3057751660L">XSLT patterns</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">7 <a href="#id3057724588L">XPath and XSLT extensions</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">7.1 <a href="#id3057725100L">Extension functions (XPath and XSLT)</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">7.2 <a href="#id3057768684L">Extension elements (XSLT)</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">7.3 <a href="#id3057769772L">Extension element API</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">7.3.1 <a href="#id3057279212L">Controlling output from XSLT extensions</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">7.3.2 <a href="#id3057279788L">Creating result tree fragments</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">7.3.3 <a href="#id3057280044L">Comunicating with the external code that invokes XSLT</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">8 <a href="#mwriter">Streaming XML output</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.1 <a href="#mwriter.begin">Starting with MarkupWriter</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.2 <a href="#mwriter.elements">How to insert elements</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.3 <a href="#mwriter.attributes">How to insert attributes</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.4 <a href="#mwriter.text">How to insert text nodes</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.5 <a href="#mwriter.chunk">How to insert a complete chunk</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.6 <a href="#mwriter.pi">How to insert processing instructions and comments</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.7 <a href="#mwriter.ns">Using namespaces</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.8 <a href="#mwriter.output">Setting up the output</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">8.9 <a href="#mwriter.examples">More examples</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">8.9.1 <a href="#mwriter.examples.xhtml">Writing XHTML with MarkupWriter</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">8.9.2 <a href="#mwriter.examples.dirlist">Writing information of directory listing as a
      XML document</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 3em">8.9.3 <a href="#id3057309740L">Building a bot</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">9 <a href="#RELAXNG">Validation using RELAX NG</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">10 <a href="#xupdate">XUpdate processing</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">10.1 <a href="#id3057324396L">XUpdate and namespaces</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">11 <a href="#xinclude">XInclude processing</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">11.1 <a href="#about_xinclude">About XInclude</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">11.2 <a href="#xinclude_in_4suite">XInclude support in 4Suite</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">11.3 <a href="#xinclude_examples">Examples</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">12 <a href="#xpointer">XPointer processing</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">12.1 <a href="#about_xpointer">About XPointer</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">12.2 <a href="#xpointer_in_4suite">XPointer support in 4Suite</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">12.3 <a href="#xpointer_examples">Examples</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">13 <a href="#id3057351212L">Comprehensive examples</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 2em">13.1 <a href="#id3057357612L">Transforming DocBook using the DocBook XSL stylesheets</a>
          <br>
        </p>
        <p style="display: inline; padding-left: 1em">14 <a href="#id3057360108L">Resources</a>
          <br>
        </p>
      </div>
      <hr>
      <div class="body">
        <div class="section"><a id="id3059709548L" name="id3059709548L"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">1 </span>Introduction</h1>
          </div>
          <p>4Suite allows users to take advantage of standard XML technologies
  rapidly and to develop and integrate Web-based applications. It also puts
  practical technologies for knowledge management projects in the hands of
  developers. It is implemented in Python with C extensions.</p>
          <p>At the core of 4Suite is a library of integrated tools (including
  convenient command-line tools) for XML processing, implementing open
  technologies such as DOM, SAX, XSLT, XInclude, XPointer, XLink, XPath,
  XUpdate, RELAX NG, and XML/SGML Catalogs.</p>
          <p>With 4Suite, you can:</p>
          <ul style="list-style-type: disc; list-style-position: outside;">
            <li>
              <p><a href="#domlette" title="DOM-like XML processing">Parse a document into an efficient
      DOM-like structure (Domlette)</a></p>
            </li>
            <li>
              <p><a href="#saxlette" title="SAX">Parse a document in event mode based on
      SAX 2 (Saxlette)</a></p>
            </li>
            <li>
              <p><a href="#xpath_engine" title="XPath queries">Run XPath queries over a parsed
      document</a></p>
            </li>
            <li>
              <p><a href="#xslt_engine" title="XSLT processing">Apply XSLT to a document, whether or
      not it has been separately parsed</a></p>
            </li>
            <li>
              <p><a href="#xupdate" title="XUpdate processing">Update a document using an XUpdate
      script</a></p>
            </li>
            <li>
              <p><a href="#RELAXNG" title="Validation using RELAX NG">Validate a document using RELAX
      NG</a></p>
            </li>
          </ul>
          <p>And much more. These tasks are covered in this manual.</p>
        </div>
        <div class="section"><a id="id3059670572L" name="id3059670572L"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">2 </span>Installation</h1>
          </div>
          <p>Please see the <a href="http://4suite.org/docs/howto/UNIX.xml">UNIX</a> or <a href="http://4suite.org/docs/howto/Windows.xml">Windows</a> install
  documents.  Remember that if you are using Cygwin on Windows, you should follow the UNIX instructions.</p>
        </div>
        <div class="section" id="domlette"><a id="domlette" name="domlette"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">3 </span>DOM-like XML processing</h1>
          </div>
          <p>Domlette is 4Suite's lightweight DOM implementation. It is optimized
  for XPath operations, speed, and relatively low memory overhead. The
  Domlette API is accessible through <tt class="systemitem">Ft.Xml.Domlette</tt>. This section describes how to
  parse, manipulate, and then serialize XML documents using this API.</p>
          <p>Below, we briefly summarize the various elements of the API that form
  the basic life span of Domlette objects.</p>
          <div class="variablelist">
            <dl>
              <dt>Parsing XML documents</dt>
              <dd>
                <p>The <tt class="systemitem">Ft.Xml</tt> module
        contains the function <tt class="methodname">Parse</tt> that gets the
        job done quickly. See <a href="#quick_reader_access" title="Quick access to the Domlette reader API">&ldquo;Quick access to the Domlette reader API&rdquo;</a> for
        details. For a bit more more advanced parsing, you will need a
        combination of the reader instances in the
        <tt class="systemitem">Ft.Xml.Domlette</tt> module and
        <tt class="methodname">Ft.Xml.CreateInputSource</tt> for constructing
        <tt class="classname">InputSource</tt> instances. In rare cases you
        might need lower-level APIs in in the
        <tt class="systemitem">Ft.Xml.InputSource</tt> module.
        Read <a href="#full_domlette_reader" title="The full Domlette reader API">&ldquo;The full Domlette reader API&rdquo;</a> if
        <tt class="methodname">Ft.Xml.Parse</tt> isn't enough.</p>
              </dd>
              <dt>Modifying and interacting with XML documents</dt>
              <dd>
                <p>The Domlette API for interacting with XML documents&mdash;accessible
        as methods of the various Domlette objects&mdash;is similar to <a href="http://www.w3.org/TR/DOM-Level-2-Core">the DOM Level 2
        specification</a>. See <a href="#domlette_API" title="Domlette API summary">&ldquo;Domlette API summary&rdquo;</a> for more
        information.</p>
              </dd>
              <dt>Serializing XML documents</dt>
              <dd>
                <p>The <tt class="systemitem">Ft.Xml.Domlette</tt>
        module provides two functions, <tt class="methodname">Print</tt> and
        <tt class="methodname">PrettyPrint</tt>, for writing your XML documents.
        The <tt class="methodname">Print</tt> function writes the XML document
        precisely as given in the model. On the other hand, the
        <tt class="methodname">PrettyPrint</tt> function adds whitespace nodes to
        your document to try to indent the resulting output nicely. See <a href="#domlette_serializing" title="Serializing Domlette nodes">&ldquo;Serializing Domlette nodes&rdquo;</a> for details.</p>
              </dd>
            </dl>
          </div>
          <div class="section"><a id="id3059835948L" name="id3059835948L"></a>
            <div>
              <h2 class="title"><span class="section-number">3.1 </span>Parsing XML documents</h2>
            </div>
            <p>We begin our discussion of the Domlette API by describing how to
    obtain a model of your XML documents to manipulate further. Because XML
    documents offer such rich functionality and exist in such varied
    environments, there can be a surprising amount of work that you must do to
    simply load your XML documents. We begin by providing a short-cut for easy
    access. We will then dive into the full suite of document loading
    utilities.</p>
            <div class="section" id="quick_reader_access"><a id="quick_reader_access" name="quick_reader_access"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.1 </span>Quick access to the Domlette reader API</h3>
              </div>
              <p>For basic document manipulations or to get started quickly, the
      <tt class="systemitem">Ft.Xml</tt> module offers a quick
      way to parse XML documents and directly obtain access to the Domlette
      interface to those documents. Within this module the function of
      interest is <tt class="methodname">Parse</tt>.</p>
              <div class="warning"><span class="label">Warning</span>
                <p>This function will get you started quickly because it
        specifically chooses some default values for some of the more advanced
        parsing features. If you are passing in a string or stream, and the
        material in <a href="#base_URIs" title="The importance of base URIs">&ldquo;The importance of base URIs&rdquo;</a>
        applies to your parsing situation, then you will want to use the
        full-featured API. In brief, if your XML document references external
        resources, you should not use this convenience function. See <a href="#full_domlette_reader" title="The full Domlette reader API">&ldquo;The full Domlette reader API&rdquo;</a> instead.</p>
              </div>
              <p>This function returns a Domlette
      <tt class="classname">Document</tt> representing the root of the document
      from the argument.</p>
              <div class="variablelist">
                <dl>
                  <dt><code class="methodsynopsis"><span class="methodname">Parse</span>(<span class="methodparam"><var class="parameter">source</var></span>)</code></dt>
                  <dd>
                    <p>The <tt class="methodname">Parse</tt> function takes a single
            argument, which is a byte string (not unicode object), file-like
            object (stream), file path or URI.</p>
                  </dd>
                </dl>
              </div>
              <div class="programlisting">
                <pre>XML = """
&lt;ham&gt;
&lt;eggs n='1'/&gt;
This is the string content with &lt;em&gt;emphasized text&lt;/em&gt; text
&lt;/ham&gt;"""

from Ft.Xml import Parse

doc = Parse(XML)
# If the above XML document were located in the file
# "target.xml", we could have used `Parse("target.xml")`.
print doc.xpath('string(ham//em[1])')</pre>
              </div>
            </div>
            <div class="section" id="full_domlette_reader"><a id="full_domlette_reader" name="full_domlette_reader"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.2 </span>The full Domlette reader API</h3>
              </div>
              <p>You create Domlette instances by parsing XML documents with the
      reader system. For general use, the <tt class="systemitem">Ft.Xml.Domlette</tt> package contains instances
      of the different reader classes that can be used directly after you
      import them. These instances include
      <tt class="constant">NonvalidatingReader</tt> and
      <tt class="constant">ValidatingReader</tt>, which provide non-validating
      parsing and validating parsing services, respectively. The validation in
      this case refers to DTD validation. For RELAX NG validation, see <a href="#RELAXNG" title="Validation using RELAX NG">&ldquo;Validation using RELAX NG&rdquo;</a>. All the reader classes (and, hence, their bundled
      instances) are described in later sections. After you have obtained one
      of these reader instances, you feed your XML document entity's byte
      stream to the reader. We summarize the available reader methods
      below.</p>
              <div class="variablelist">
                <dl>
                  <dt><code class="methodsynopsis"><span class="methodname">parseUri</span>(<span class="methodparam"><var class="parameter">uri</var></span>)</code></dt>
                  <dd>
                    <p>The <tt class="methodname">parseUri</tt> method takes a single
            argument; this <i class="parameter"><tt>uri</tt></i> argument is the absolute
            URI of the document entity to parse. The URI will be dereferenced
            by the default resolver.</p>
                  </dd>
                  <dt><code class="methodsynopsis"><span class="methodname">parseString</span>(<span class="methodparam"><var class="parameter">st</var></span>, <span class="methodparam"><var class="parameter">uri</var></span>)</code></dt>
                  <dd>
                    <p>The <tt class="methodname">parseString</tt> method takes two
            arguments; <i class="parameter"><tt>st</tt></i> is the XML document entity in
            the form of an encoded Python string (<strong class="emphasis">not a
            Unicode string</strong>). See the next section for details on
            the <i class="parameter"><tt>uri</tt></i> argument.</p>
                  </dd>
                  <dt><code class="methodsynopsis"><span class="methodname">parseStream</span>(<span class="methodparam"><var class="parameter">stream</var></span>, <span class="methodparam"><var class="parameter">uri</var></span>)</code></dt>
                  <dd>
                    <p>The <tt class="methodname">parseStream</tt> method takes two
            arguments; <i class="parameter"><tt>stream</tt></i> is a Python file-like
            object that can supply the document entity's bytes via
            <tt class="methodname">read</tt>() calls. See the next section for
            details on the <i class="parameter"><tt>uri</tt></i> argument.</p>
                  </dd>
                  <dt><code class="methodsynopsis"><span class="methodname">parse</span>(<span class="methodparam"><var class="parameter">inputSource</var></span>)</code></dt>
                  <dd>
                    <p>The <tt class="methodname">parse</tt> method takes a single
            argument; <i class="parameter"><tt>inputSource</tt></i> is an
            <tt class="classname">Ft.Xml.InputSource.InputSource</tt> object,
            described in <a href="#InputSources" title="InputSource objects">&ldquo;InputSource objects&rdquo;</a>.</p>
                  </dd>
                </dl>
              </div>
              <p>The next two sections cover some of the issues that you should
      understand before using these functions. Then we start seeing some
      examples in <a href="#NonvalidatingReader" title="NonvalidatingReader">&ldquo;<tt class="varname">NonvalidatingReader</tt>&rdquo;</a>.</p>
            </div>
            <div class="section" id="base_URIs"><a id="base_URIs" name="base_URIs"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.3 </span>The importance of base URIs</h3>
              </div>
              <p>In the first 3 methods listed in the previous section, the
      <i class="parameter"><tt>uri</tt></i> argument is the URI of the document entity
      that you are feeding to the parser. It is a very important&mdash;but often
      overlooked&mdash;concept in document processing.</p>
              <p>The URI gives the document entity a unique identifier that can
      used to refer to the document as a whole. Also, each Domlette node
      derived from a particular entity inherits that entity's URI as the
      node's <tt class="varname">baseURI</tt> property, unless an alternative base
      URI was indicated, such as with <tt class="sgmltag">xml:base</tt>, or if part of the document was
      loaded as an external entity or XInclude.</p>
              <p>The document's URI is also used as the "base URI" for resolving
      any relative URI references that may appear within the document itself.
      Relative URI references may occur in a document in places like:</p>
              <ul style="list-style-type: disc; list-style-position: outside;">
                <li>
                  <p><span class="markup">&lt;!DOCTYPE&gt;</span> or
          <span class="markup">&lt;!ENTITY&gt;</span>, immediately following the keyword
          <span class="markup">SYSTEM</span></p>
                </li>
                <li>
                  <p><tt class="sgmltag">&lt;xsl:import&gt;</tt> and
          <tt class="sgmltag">&lt;xsl:include&gt;</tt>, in the value
          of the <tt class="sgmltag">href</tt> attribute</p>
                </li>
                <li>
                  <p><tt class="sgmltag">&lt;xi:include&gt;</tt>, in the
          value of the <tt class="sgmltag">href</tt>
          attribute</p>
                </li>
                <li>
                  <p><tt class="sgmltag">&lt;exsl:document&gt;</tt>, in
          the value of the <tt class="sgmltag">href</tt>
          attribute</p>
                </li>
                <li>
                  <p>the arguments to XSLT's <tt class="function">document()</tt>
          function</p>
                </li>
              </ul>
              <p>It is a common misconception that relative URI references in a
      document's content are considered to be relative to the processor's
      current working directory. They are actually resolved relative to the
      URI of the document that contains the relative URI reference (more
      specifically, relative to the URI of the <em class="emphasis">entity</em> in which the reference occurs, keeping in
      mind that a document may be comprised of multiple entities, i.e.,
      separate files).</p>
              <p>In all cases, the document URI that you supply in the reader API
      must be "absolute", which means that it has a scheme, e.g.
      "<tt class="uri">http://spam/eggs.xml</tt>", not just
      "<tt class="filename">/spam/eggs.xml</tt>" or
      "<tt class="filename">eggs.xml</tt>".</p>
              <p>If you know there are not going to be any relative URI references
      to resolve during initial parsing or during processing of the Domlette
      by other tools, then you can safely omit the argument, or, preferably,
      supply a dummy URI like "<tt class="uri">urn:dummy</tt>" or
      "<tt class="uri">http://spam/eggs.xml</tt>". If you choose to omit URI arguments
      from APIs that need them, you may get a Python warning, and a random
      URI&mdash;which is probably not what you want&mdash;will be assigned.</p>
              <p>If you've understood all this and yet you want to just go ahead
      and not specify a base URI, you may have to turn off the likely
      warnings.  You can do so with code such as in the following example.</p>
              <div class="programlisting">
                <pre>import  Ft.Xml.Domlette
import warnings
def disable_warnings(*args): pass

warnings.filterwarnings("ignore", category=Warning)
warnings.showwarning = disable_warnings

XML = "&lt;spam/&gt;"
doc  = Ft.Xml.Domlette.NonvalidatingReader.parseString(XML)
Ft.Xml.Domlette.Print(doc)
</pre>
              </div>
              <p>You can also in such a case use the convenience function
      <tt class="methodname">Ft.Xml.Parse</tt> (see above).</p>
            </div>
            <div class="section"><a id="id3059860268L" name="id3059860268L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.4 </span>Parsing XML that's already a Unicode string</h3>
              </div>
              <p>Because 4Suite is trying to provide as thin a wrapper as possible
      to the underlying parser, and due to complexities in the APIs of these
      parsers, there is no API in 4Suite for parsing Python's Unicode
      strings.</p>
              <p>If your XML is in the form of a Unicode string, you must encode
      the string as bytes so that the underlying parser can read it. Once you
      have an encoded string, you can pass it to the reader's
      <tt class="methodname">parseString</tt>(), or wrap it in an
      <tt class="classname">InputSource</tt> using
      <tt class="methodname">Ft.Xml.CreateInputSource</tt>, or the
      <tt class="methodname">fromString</tt>() method of an
      <tt class="classname">InputSourceFactory</tt>. If the string is not UTF-16 or
      UTF-8 encoded, then you must tell the reader what encoding it actually
      uses. You can do this either by writing or replacing the XML declaration
      in the string itself, or (much easier) setting the optional encoding
      keyword argument in the reader's <tt class="methodname">parseString</tt>()
      method or the <tt class="classname">InputSourceFactory</tt>'s
      <tt class="methodname">fromString</tt>() method. For an example, see <a href="http://uche.ogbuji.net/tech/akara/nodes/2004-06-12/external-encoding">the
      Akara article on external encoding declarations</a>.</p>
            </div>
            <div class="section" id="NonvalidatingReader"><a id="NonvalidatingReader" name="NonvalidatingReader"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.5 </span><tt class="varname">NonvalidatingReader</tt></h3>
              </div>
              <p>Use <tt class="varname">NonvalidatingReader</tt> for basic parsing.
      <tt class="varname">NonvalidatingReader</tt> performs its parsing without
      validating against a DTD.</p>
              <p>The following example will parse an XML source taken from the
      supplied URI, which is treated as a URL by the default resolver.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReader
doc = NonvalidatingReader.parseUri(
  "http://www.w3.org/2000/08/w3c-synd/home.rss")</pre>
              </div>
              <p>The following example also parses an XML source taken from the
      supplied URI, which is treated as a URL. In this case, the default
      resolver tries to read the XML source from the filesystem.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReader
doc = NonvalidatingReader.parseUri("file:///tmp/spam.xml")</pre>
              </div>
              <p>The following example parses XML from the filesystem. When given a
      relative file path in the local OS's format, we must first convert that
      path to a URI that our reader objects can use.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReader
from Ft.Lib import Uri
file_uri = Uri.OsPathToUri('spam.xml')
doc = NonvalidatingReader.parseUri(file_uri)</pre>
              </div>
              <p>The following example parses XML from a string. Note that it does
      not provide a document/base URI.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReader
doc = NonvalidatingReader.parseString("&lt;spam&gt;eggs&lt;/spam&gt;")</pre>
              </div>
              <p>In the following example, we are parsing XML from a string in a
      case where the document does need a base URI to be specified.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReader
s = """&lt;!DOCTYPE spam [ &lt;!ENTITY eggs "eggs.xml"&gt; ]&gt;
&lt;spam&gt;&amp;eggs;&lt;/spam&gt;"""
doc = NonvalidatingReader.parseString(s, 'http://foo/test/spam.xml')
# during parsing, the replacement text for &amp;eggs;
# will be obtained from http://foo/test/eggs.xml</pre>
              </div>
              <p>In all of the above examples, doc is now a Domlette node object.
      4Suite currently offers one Domlette implementation, written in C,
      called cDomlette.</p>
            </div>
            <div class="section"><a id="id3059861676L" name="id3059861676L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.6 </span><tt class="classname">EntityReader</tt> Examples</h3>
              </div>
              <p>Sometimes you need to parse a fragment of XML rather than the full
      document. If operating in non-validating mode is sufficient, Domlette
      has a reader that can handle this case. When parsing such a fragment,
      <tt class="property">EntityReader</tt> returns a Domlette document fragment
      rather than a document object.</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import EntityReader
s = """
&lt;spam1&gt;eggs&lt;/spam1&gt;
&lt;spam2&gt;more eggs&lt;/spam2&gt;
"""
docfrag = EntityReader.parseString(s, 'http://foo/test/spam.xml')</pre>
              </div>
              <div class="note"><span class="label">Note</span>
                <p>The content parsed by <tt class="classname">EntityReader</tt> must
        be an XML External Parsed Entity. This means that it can't be just any
        XML document. The main limitation is that it must not have a a
        document type declaration.</p>
              </div>
            </div>
            <div class="section"><a id="id3059862252L" name="id3059862252L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.7 </span><tt class="classname">ValidatingReader</tt></h3>
              </div>
              <p>If you want to validate a document with a DTD as you parse it, use
      the <tt class="classname">ValidatingReader</tt> object instead. If
      <tt class="classname">ValidatingReader</tt> discovers that the document that
      it is currently parsing is invalid, then it throws a
      <tt class="classname">Ft.Xml.ReaderException</tt> and does not finish
      parsing the document. The following example illustrates these
      concepts.</p>
              <div class="programlisting">
                <pre># ValidatingReader is a global instance
from Ft.Xml.Domlette import ValidatingReader

XML = """&lt;!DOCTYPE a [
  &lt;!ELEMENT a (b, b)&gt;
  &lt;!ELEMENT b EMPTY&gt;
]&gt;
&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;/a&gt;"""

doc = ValidatingReader.parseString(XML, "urn:x-example:valid-a")
# And of course, as with other readers, you can use `parse`, `parseUri`, and
# `parseStream` as well.

# The following document, however, is invalid because an `a` element can only
# have two `b` children according to its DTD.
XML = """&lt;!DOCTYPE a [
  &lt;!ELEMENT a (b, b)&gt;
  &lt;!ELEMENT b EMPTY&gt;
]&gt;
&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;b/&gt;&lt;/a&gt;"""

# This throws a `Ft.Xml.ReaderException` when it encounters invalid structure,
# and does not finish parsing the document into `doc`.
doc = ValidatingReader.parseString(XML, "urn:x-example:invalid-a")</pre>
              </div>
            </div>
            <div class="section"><a id="id3059862956L" name="id3059862956L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.8 </span><tt class="classname">NoExtDtdReader</tt></h3>
              </div>
              <p>When using <tt class="classname">NonvalidatingReader</tt> to parse a
      document, that document's DTD is still opened and read to obtain
      information such as entity declarations and default attribute values.
      You cannot suppress reading of the internal DTD subset, but you can
      prevent the external subset from being accessed by using
      <tt class="classname">NoExtDtdReader</tt>. This won't affect the processing
      of external parameter entities defined in the internal DTD subset. Use
      this object as you would use
      <tt class="classname">NonvalidatingReader</tt>.</p>
            </div>
            <div class="section"><a id="id3059691116L" name="id3059691116L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.9 </span>Creating your own reader instance</h3>
              </div>
              <p>In some cases you might not want to use the global reader
      instances. For instance in multithreaded use, you might want a reader
      per thread. Or you might want to change some of the parameters on the
      readers. If so, you can create your own reader instance:</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import NonvalidatingReaderBase
reader = NonvalidatingReaderBase()
doc = reader.parseUri("http://xmlhack.com/read.php?item=1560")</pre>
              </div>
              <p>Instead of <tt class="classname">NonvalidatingReaderBase</tt>, you
      could instead use <tt class="classname">NoExtDtdReaderBase</tt> or
      <tt class="classname">ValidatingReaderBase</tt>, depending on your needs.
      Each of these 3 readers take an optional
      <i class="parameter"><tt>inputSourceFactory</tt></i> constructor argument, which
      you can use to supply a custom URI resolver.</p>
            </div>
            <div class="section" id="InputSources"><a id="InputSources" name="InputSources"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.10 </span>InputSource objects</h3>
              </div>
              <p>All of the previous examples involve parsing URIs or strings of
      data. You can also handle <tt class="classname">InputSource</tt> objects. An
      <tt class="classname">InputSource</tt> is an object that encapsulates a
      source of encoded text for parsing, and a URI resolver. The advantage to
      using an <tt class="classname">InputSource</tt> is that it provides a
      standard API to the text stream, and&mdash;perhaps more importantly&mdash;allows you
      to associate a custom URI resolver with the stream.</p>
              <p>Normally, you can just get an <tt class="classname">InputSource</tt>
by calling the convenience function <tt class="methodname">Ft.Xml.CreateInputSource</tt> with a single
argument, which is a string (not Unicode object), file-like
object (stream), file path or URI.  You can then pass the
      <tt class="classname">InputSource</tt> object to the reader's
      <tt class="methodname">parse</tt>() method, as in the following
      example.
</p>
              <div class="programlisting">
                <pre>from Ft.Xml import InputSource, CreateInputSource
from Ft.Xml.Domlette import NonvalidatingReader

#
# Use CreateInputSource to parse a URL:
#
isrc = CreateInputSource("http://xmlhack.com/read.php?item=1560")
doc1 = NonvalidatingReader.parse(isrc)
#
# Or a string:
#
isrc = CreateInputSource("&lt;spam&gt;eggs&lt;/spam&gt;", "http://spam.com/base")
doc2 = NonvalidatingReader.parse(isrc)
#
# InputSource is a file-like object, so you can treat it as such:
#
isrc = CreateInputSource("http://xmlhack.com/read.php?item=1560")
raw_text = isrc.read()
#
# The uri/system ID you used for it is maintained
#
print isrc.uri
#
# You can also create other InputSources from URIs relative to this one
#
isrc2 = isrc.resolve("read.php?item=1703")</pre>
              </div>
              <p></p>
              <p>
      If you need lower-level control you can use an
      <tt class="classname">InputSourceFactory</tt> instance, calling the appropriate method:
      <tt class="methodname">fromUri</tt>(<i class="parameter"><tt>uri</tt></i>),
      <tt class="methodname">fromString</tt>(<i class="parameter"><tt>st</tt></i>), or
      <tt class="methodname">fromStream</tt>(<i class="parameter"><tt>stream</tt></i>), much
      like the reader API described earlier.  The following listing is
      functionally equivalent to the above one.</p>
              <div class="programlisting">
                <pre>from Ft.Xml import InputSource
from Ft.Xml.Domlette import NonvalidatingReader

factory = InputSource.DefaultFactory
isrc = factory.fromUri("http://xmlhack.com/read.php?item=1560")
doc1 = NonvalidatingReader.parse(isrc)
#
# The factory is reusable. Here we also parse a string:
#
isrc = factory.fromString("&lt;spam&gt;eggs&lt;/spam&gt;", "http://spam.com/base")
doc2 = NonvalidatingReader.parse(isrc)
#
# InputSource is a file-like object, so you can treat it as such:
#
isrc = factory.fromUri("http://xmlhack.com/read.php?item=1560")
raw_text = isrc.read()
#
# The uri/system ID you used for it is maintained
#
print isrc.uri
#
# You can also create other InputSources from URIs relative to this one
#
isrc2 = isrc.resolve("read.php?item=1703")</pre>
              </div>
            </div>
            <div class="section" id="converting_DOM"><a id="converting_DOM" name="converting_DOM"></a>
              <div>
                <h3 class="title"><span class="section-number">3.1.11 </span>Converting from other DOM libraries</h3>
              </div>
              <p>You can convert another Python DOM object (e.g. 4DOM or minidom)
      to a Domlette object using the function
      <tt class="methodname">ConvertDocument</tt>:</p>
              <div class="programlisting">
                <pre>from Ft.Xml.Domlette import ConvertDocument
converted_document = ConvertDocument(oldDocument, documentURI=u'http://www.example.org/')</pre>
              </div>
              <p>The <i class="parameter"><tt>DocumentURI</tt></i> parameter provides a base
      URI for the converted nodes. If not specified, attributes documentURI
      and then baseURI are checked in the source DOM, as defined in <a href="http://www.w3.org/TR/DOM-Level-3-Core">DOM Level 3</a>. If no
      URI is found in this way, a warning is issued and a UUID URI is
      generated for the new Domlette object.</p>
            </div>
          </div>
          <div class="section" id="domlette_API"><a id="domlette_API" name="domlette_API"></a>
            <div>
              <h2 class="title"><span class="section-number">3.2 </span>Domlette API summary
                <br><span class="subtitle">Interacting with Domlette documents</span></h2>
            </div>
            <p>You will use a large part of the Domlette API to interact with the
    model of your XML documents. The implementation of this part of the API is
    found in the <tt class="systemitem">Ft.Xml.cDomlette</tt>
    module. This part of the API allows you to navigate around a document and
    modify the content of that document. It is very similar to <a href="http://www.w3.org/TR/DOM-Level-2-Core">the DOM Level 2
    specification</a> and follows some of <a href="http://www.w3.org/TR/DOM-Level-3-Core">the DOM Level 3
    specification</a>; feel free to refer to those specifications and the
    4Suite API documentation for details about the intended behavior of this
    API. You can find brief descriptions of the methods and attributes
    provided by this API listed below. This API is also nearly the same as the
    API for <tt class="systemitem">xml.dom</tt>, which is bundled
    with Python. The node type constants are inherited directly from
    <tt class="literal">xml.dom.Node</tt>.</p>
            <p>Many objects that you will work with in the Domlette API are
    descendents of the Domlette <tt class="classname">Node</tt> class.
    <tt class="classname">Document</tt>s, document fragments (of class
    <tt class="classname">DocumentFragment</tt>), <tt class="classname">Element</tt>s,
    attributes (class <tt class="classname">Attr</tt>), text (class
    <tt class="classname">Text</tt>), processing instructions (class
    <tt class="classname">ProcessingInstruction</tt>), and comments (class
    <tt class="classname">Comment</tt>) are all nodes; any node operations are
    defined on objects of these types, as well. Some operations do not make
    sense on some objects, however. For example, it does not make sense to add
    children to an attribute node.</p>
            <p>In the DOM model of XML documents, there is a
    <tt class="classname">Document</tt> node which represents the starting point
    for the other pieces of the document. This node is <strong class="emphasis">not</strong> the root element of the document; rather, the
    <tt class="classname">Document</tt> node <strong class="emphasis">contains</strong> the root element as its only element
    child. The <tt class="classname">Document</tt> node may have other children,
    though, such as processing instructions and comments.</p>
            <p>You can easily access properties of a node directly. The following
    properties are available on any node. These properties generally store
    information about the structure of the document in the near "vicinity" of
    the target node.</p>
            <div class="variablelist">
              <p class="title"><b>Properties available on every Node
      object</b></p>
              <dl>
                <dt><tt class="property">attributes</tt></dt>
                <dd>
                  <p>This is a python dictionary containing the attributes defined
          on the target node. The key for the dictionary is a tuple containing
          the namespace and local name of the attribute. The value associated
          with this attribute name tuple is the attribute (of class
          <tt class="classname">Attr</tt>) itself.</p>
                  <div class="programlisting">
                    <pre>node = Parse("&lt;foo a='1'/&gt;")
print node.childNodes[0].attributes</pre>
                  </div>
                  <div class="screen">
                    <pre>{(None, u'a'): &lt;Attr at 0x40870ecc: name u'a', value u'1'&gt;}</pre>
                  </div>
                </dd>
                <dt><tt class="property">baseURI</tt></dt>
                <dd>
                  <p>This is the base URI in scope for the target node as a Python
          unicode string.</p>
                </dd>
                <dt><tt class="property">childNodes</tt></dt>
                <dd>
                  <p>This is the Python list of all the node children of the target
          node. Note that in DOM terminology, the attributes of a node are
          <strong class="emphasis">not</strong> children of that node.</p>
                  <div class="programlisting">
                    <pre>node = Parse("&lt;foo a='1'/&gt;")
print node.childNodes</pre>
                  </div>
                  <div class="screen">
                    <pre>[&lt;Element at 0x4086052c: name u'foo', 1 attributes, 0 children&gt;]</pre>
                  </div>
                </dd>
                <dt><tt class="property">firstChild</tt></dt>
                <dd>
                  <p>This is the first child node of the target node. This is
          equivalent to <tt class="code">childNodes[0]</tt>, and is a useful property
          for quickly walking the document tree.</p>
                  <div class="programlisting">
                    <pre>node = Parse("&lt;foo a='1'/&gt;")
print node.firstChild</pre>
                  </div>
                  <div class="screen">
                    <pre>&lt;Element at 0x40860a6c: name u'foo', 1 attributes, 0 children&gt;</pre>
                  </div>
                </dd>
                <dt><tt class="property">lastChild</tt></dt>
                <dd>
                  <p>This is the last child node of the target node. This is
          equivalent to <tt class="code">childNodes[-1]</tt>.</p>
                  <div class="programlisting">
                    <pre>node = Parse("&lt;foo a='1'/&gt;&lt;!--Hi!--&gt;")
print node.lastChild</pre>
                  </div>
                  <div class="screen">
                    <pre>&lt;Comment at 0x4087caf4: u'Hi!'&gt;</pre>
                  </div>
                </dd>
                <dt><tt class="property">localName</tt></dt>
                <dd>
                  <p>This is the local name of the target node as a Python unicode
          string.</p>
                </dd>
                <dt><tt class="property">namespaceURI</tt></dt>
                <dd>
                  <p>This is the namespace URI of the target node as a Python
          unicode string.</p>
                </dd>
                <dt><tt class="property">nextSibling</tt></dt>
                <dd>
                  <p>This is the node immediately following the target node, or
          <tt class="literal">None</tt> if the target node is the last child of its parent
          (or if the target node is an attribute, as attributes are
          unordered).</p>
                </dd>
                <dt><tt class="property">nodeValue</tt></dt>
                <dd>
                  <p>This is the value of the target node as a Python unicode
          string, if the target node has a string value. If not, this is
          <tt class="literal">None</tt>. To illustrate some of the possibilities,
          attributes and text nodes have values, while elements and documents
          do not.</p>
                </dd>
                <dt><tt class="property">ownerDocument</tt></dt>
                <dd>
                  <p>This is the <tt class="classname">Document</tt> node in which the
          target node is contained.</p>
                </dd>
                <dt><tt class="property">parentNode</tt></dt>
                <dd>
                  <p>This is the parent of the target node. If the target node is a
          <tt class="classname">Document</tt> node, then this will be
          <tt class="literal">None</tt>; <tt class="classname">Document</tt> nodes do not have
          parents.</p>
                </dd>
                <dt><tt class="property">prefix</tt></dt>
                <dd>
                  <p>This is the namespace prefix of the current node, or
          <tt class="literal">None</tt> if the current node does not (or cannot) have a
          namespace prefix.</p>
                </dd>
                <dt><tt class="property">previousSibling</tt></dt>
                <dd>
                  <p>This is the node immediately preceding the target node, or
          <tt class="literal">None</tt> if the target node is the first child of its
          parent (or if the target node is an attribute, as attributes are
          unordered).</p>
                </dd>
                <dt><tt class="property">rootNode</tt></dt>
                <dd>
                  <p>This is a synonym for
          <tt class="property">ownerDocument</tt>.</p>
                </dd>
                <dt><tt class="property">xmlBase</tt></dt>
                <dd>
                  <p>This is a synonym for <tt class="property">baseURI</tt>.</p>
                </dd>
              </dl>
            </div>
            <p>In addition to accessing the structure relative to a node, there are
    also a set of operations that we can perform on these structures,
    including a variety of operations for modifying the document. Some of
    these methods allow you to add new nodes in various places; note that in
    the DOM, only <tt class="classname">Document</tt> nodes can create new nodes. See <a href="#Document_methods" title="Methods available to Document&#10;      objects">&ldquo;Methods available to <tt class="classname">Document</tt>
      objects&rdquo;</a> for details. The following methods are
    available on any node.</p>
            <div class="variablelist">
              <p class="title"><b>Methods available to every Node
      object</b></p>
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">appendChild</span>(<span class="methodparam"><var class="parameter">node</var></span>)</code></dt>
                <dd>
                  <p>This method adds <i class="parameter"><tt>node</tt></i> as the last child
          of the current instance. This is useful for manually building a
          document in breadth-first document order.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">insertBefore</span>(<span class="methodparam"><var class="parameter">newChild</var></span>, <span class="methodparam"><var class="parameter">refChild</var></span>)</code></dt>
                <dd>
                  <p>This method adds the node <i class="parameter"><tt>newChild</tt></i> to
          the current instance immediately before child node
          <i class="parameter"><tt>refChild</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">replaceChild</span>(<span class="methodparam"><var class="parameter">newChild</var></span>, <span class="methodparam"><var class="parameter">oldChild</var></span>)</code></dt>
                <dd>
                  <p>This method replaces the child node
          <i class="parameter"><tt>oldChild</tt></i> with the
          <i class="parameter"><tt>newChild</tt></i> node.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">removeChild</span>(<span class="methodparam"><var class="parameter">oldChild</var></span>)</code></dt>
                <dd>
                  <p>This method removes the <i class="parameter"><tt>oldChild</tt></i> node
          as a child of the instance node.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">cloneNode</span>(<span class="methodparam"><var class="parameter">deep</var></span>)</code></dt>
                <dd>
                  <p>This method returns a new copy of the current instance. If
          (and only if) <i class="parameter"><tt>deep</tt></i> is true, then we copy
          deeply: the node's attributes and children are also copied
          deeply.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">isSameNode</span>(<span class="methodparam"><var class="parameter">otherNode</var></span>)</code></dt>
                <dd>
                  <p>This method determines whether the instance node and
          <i class="parameter"><tt>otherNode</tt></i> are the same node based upon object
          identity.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">normalize</span>()</code></dt>
                <dd>
                  <p>This method merges any adjacent text nodes in the attributes
          or descendents of the current instance.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">hasChildNodes</span>()</code></dt>
                <dd>
                  <p>This method returns true if and only if the instance node has
          any child nodes.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">xpath</span>(<span class="methodparam"><var class="parameter">expr</var></span>, <span class="methodparam"><var class="parameter">explicitNss</var></span>)</code></dt>
                <dd>
                  <p>This method evaluates the XPath expression
          <i class="parameter"><tt>expr</tt></i> with the current instance as the
          expression context and returns an appropriately-valued result. The
          <i class="parameter"><tt>explicitNss</tt></i> parameter is optional; it is a
          Python dictionary mapping namespace prefixes to namespaces for use
          in the expression. See <a href="#xpath_engine" title="XPath queries">&ldquo;XPath queries&rdquo;</a> for
          details.</p>
                </dd>
              </dl>
            </div>
            <p>In addition to their behavior as nodes,
    <tt class="classname">Document</tt> nodes are uniquely responsible for a
    number of tasks. For example, only <tt class="classname">Document</tt> nodes
    can create other nodes. The following methods are availble only to
    <tt class="classname">Document</tt> nodes.</p>
            <div class="variablelist" id="Document_methods">
              <p class="title"><b>Methods available to Document
      objects</b></p>
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">createElementNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">qualifiedName</var></span>)</code></dt>
                <dd>
                  <p>This method creates and returns a new
          <tt class="classname">Element</tt> with the given namespace URI and
          qualified name.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createAttributeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">qualifiedName</var></span>)</code></dt>
                <dd>
                  <p>This method creates and returns a new attribute
          (<tt class="classname">Attr</tt> object) with the given namespace URI
          and qualified name.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createTextNode</span>(<span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method creates and returns a new
          <tt class="classname">Text</tt> node with the string value of
          <i class="parameter"><tt>data</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createProcessingInstruction</span>(<span class="methodparam"><var class="parameter">target</var></span>, <span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method creates and returns a new processing instruction
          (<tt class="classname">ProcessingInstruction</tt> object) with the given
          <i class="parameter"><tt>target</tt></i> name and contents taken from
          <i class="parameter"><tt>data</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createComment</span>(<span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method creates and returns a new
          <tt class="classname">Comment</tt> with the string value of
          <i class="parameter"><tt>data</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createDocumentFragment</span>()</code></dt>
                <dd>
                  <p>This method creates and returns a new, empty document fragment
          (<tt class="classname">DocumentFragment</tt> object).</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">importNode</span>(<span class="methodparam"><var class="parameter">importedNode</var></span>, <span class="methodparam"><var class="parameter">deep</var></span>)</code></dt>
                <dd>
                  <p>Nodes can only belong to one document at a time. This method
          creates a copy of the node <i class="parameter"><tt>importedNode</tt></i> that
          belongs to the instance (but which does not yet have a parent). If
          (and only if) <i class="parameter"><tt>deep</tt></i> is true, then we copy
          deeply: the node's attributes and children are also copied deeply
          and imported.</p>
                </dd>
              </dl>
            </div>
            <p>Document nodes also have a number of properties that are not found
    on other nodes. These properties are summarized in the following
    list.</p>
            <div class="variablelist" id="Document_properties">
              <p class="title"><b>Properties available on Document
      objects</b></p>
              <dl>
                <dt><tt class="property">doctype</tt></dt>
                <dd>
                  <p>This is a <tt class="classname">DocumentType</tt> object that
          encapsulates info about the document's "type", as described in its
          DOCTYPE tag. In Domlette, which doesn't use such objects, the value
          of the <tt class="property">doctype</tt> property will always be
          <tt class="literal">None</tt>.</p>
                </dd>
                <dt><tt class="property">documentElement</tt></dt>
                <dd>
                  <p>This is the root element of the document.</p>
                </dd>
                <dt><tt class="property">documentURI</tt></dt>
                <dd>
                  <p>This is the URI that identifies the document.</p>
                </dd>
                <dt><tt class="property">implementation</tt></dt>
                <dd>
                  <p>This is the <tt class="classname">DOMImplementation</tt> that
          created the document.</p>
                </dd>
                <dt><tt class="property">publicId</tt></dt>
                <dd>
                  <p>This Domlette-specific property is the public ID of the DTD of
          this document.</p>
                </dd>
                <dt><tt class="property">rootNode</tt></dt>
                <dd>
                  <p>This refers to the current instance.</p>
                </dd>
                <dt><tt class="property">systemId</tt></dt>
                <dd>
                  <p>This Domlette-specific property is the system ID of the DTD of
          this document.</p>
                </dd>
                <dt><tt class="property">unparsedEntities</tt></dt>
                <dd>
                  <p>This is the list of unparsed entities in the current
          document.</p>
                </dd>
              </dl>
            </div>
            <p>Attributes (<tt class="classname">Attr</tt> objects) do not have any
    special methods, but they do have a few additional properties. These
    properties are summarized in the following list.</p>
            <div class="variablelist">
              <p class="title"><b>Properties available on Attr
      objects</b></p>
              <dl>
                <dt><tt class="property">name</tt></dt>
                <dd>
                  <p>This is the qualified name of the current instance.</p>
                </dd>
                <dt><tt class="property">nodeName</tt></dt>
                <dd>
                  <p>This is a synonym for the <tt class="property">name</tt>
          property.</p>
                </dd>
                <dt><tt class="property">ownerElement</tt></dt>
                <dd>
                  <p>This is a synonym for the <tt class="property">parentNode</tt>
          property.</p>
                </dd>
                <dt><tt class="property">specified</tt></dt>
                <dd>
                  <p>You will probably never need this property. It is always
          <tt class="literal">1</tt>. DOM says it should be <tt class="literal">0</tt> if
          it is present through defaulting, rather than explicitly specified
          in the document. This is only possible if the DOM implementation
          preserves certain details from DTD processing, which 4Suite never
          does. Therefore the value is always <tt class="literal">0</tt>.</p>
                </dd>
                <dt><tt class="property">value</tt></dt>
                <dd>
                  <p>This is a synonym for the <tt class="property">nodeValue</tt>
          property.</p>
                </dd>
              </dl>
            </div>
            <p>Since attributes can only be attached to elements,
    <tt class="classname">Element</tt> objects have a set of special methods for
    managing which attributes are attached to them. We describe these methods
    below.</p>
            <div class="variablelist">
              <p class="title"><b>Methods available to Element
      objects</b></p>
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">hasAttributeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">localName</var></span>)</code></dt>
                <dd>
                  <p>This method returns true if the current instance has an
          attribute with the given namespace URI and local name, and false
          otherwise.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">getAttributeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">localName</var></span>)</code></dt>
                <dd>
                  <p>This method returns the attribute <strong class="emphasis">value</strong> of the attribute with the given
          namespace URI and local name, if one exists. If not, this returns
          <tt class="literal">None</tt>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">getAttributeNodeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">localName</var></span>)</code></dt>
                <dd>
                  <p>This method returns the <tt class="classname">Attr</tt> object of
          the attribute with the given namespace URI and local name, if one
          exists. If not, this returns <tt class="literal">None</tt>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">removeAttributeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">localName</var></span>)</code></dt>
                <dd>
                  <p>This method removes the attribute with the given namespace URI
          and local name from the current instance element.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">removeAttributeNode</span>(<span class="methodparam"><var class="parameter">node</var></span>)</code></dt>
                <dd>
                  <p>This method removes the attribute <i class="parameter"><tt>node</tt></i>
          from the current instance element.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">setAttributeNS</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">qualifiedName</var></span>, <span class="methodparam"><var class="parameter">value</var></span>)</code></dt>
                <dd>
                  <p>This method adds an attribute or replaces an attribute with
          the specified namespace URI and qualified name and sets the content
          of that attribute to <i class="parameter"><tt>value</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">setAttributeNodeNS</span>(<span class="methodparam"><var class="parameter">node</var></span>)</code></dt>
                <dd>
                  <p>This method adds or replaces an attribute using the
          <tt class="classname">Attr</tt> object
          <i class="parameter"><tt>node</tt></i>.</p>
                </dd>
              </dl>
            </div>
            <p><tt class="classname">Element</tt>s also have several properties above
    and beyond what they get from being <tt class="classname">Node</tt>s. See the
    list below for details.</p>
            <div class="variablelist">
              <p class="title"><b>Properties available on Element
      objects</b></p>
              <dl>
                <dt><tt class="property">nodeName</tt></dt>
                <dd>
                  <p>This is the qualified name of the current instance.</p>
                </dd>
                <dt><tt class="property">tagName</tt></dt>
                <dd>
                  <p>This is a synonym for <tt class="property">nodeName</tt>.</p>
                </dd>
              </dl>
            </div>
            <p>Both <tt class="classname">Text</tt> and <tt class="classname">Comment</tt>
    nodes are also more general <tt class="classname">CharacterData</tt> nodes in
    the DOM. <tt class="classname">CharacterData</tt> nodes have several
    additional properties and methods for managing the string data that they
    contain. The individual <tt class="classname">Text</tt> and
    <tt class="classname">Comment</tt> nodes, however, do not add any
    functionality to their general <tt class="classname">CharacterData</tt> parent
    class. You can find descriptions of the properties and methods offered by
    <tt class="classname">CharacterData</tt> objects below.</p>
            <div class="variablelist">
              <p class="title"><b>Properties available on CharacterData
      objects</b></p>
              <dl>
                <dt><tt class="property">data</tt></dt>
                <dd>
                  <p>This is the string content of the current instance.</p>
                </dd>
                <dt><tt class="property">length</tt></dt>
                <dd>
                  <p>This is the length of the string content of the current
          instance.</p>
                </dd>
                <dt><tt class="property">nodeValue</tt></dt>
                <dd>
                  <p>This is a synonym for <tt class="property">data</tt>.</p>
                </dd>
              </dl>
            </div>
            <div class="variablelist">
              <p class="title"><b>Methods available to CharacterData
      objects</b></p>
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">insertData</span>(<span class="methodparam"><var class="parameter">offset</var></span>, <span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method inserts the string <i class="parameter"><tt>data</tt></i>
          into the content of the current instance at the index specified by
          <i class="parameter"><tt>offset</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">appendData</span>(<span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method appends the string <i class="parameter"><tt>data</tt></i> to
          the end of the value of the current instance.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">replaceData</span>(<span class="methodparam"><var class="parameter">offset</var></span>, <span class="methodparam"><var class="parameter">count</var></span>, <span class="methodparam"><var class="parameter">data</var></span>)</code></dt>
                <dd>
                  <p>This method replaces <i class="parameter"><tt>count</tt></i> number of
          characters found at index <i class="parameter"><tt>offset</tt></i> in the
          current instance with the string <i class="parameter"><tt>data</tt></i>.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">substringData</span>(<span class="methodparam"><var class="parameter">offset</var></span>, <span class="methodparam"><var class="parameter">count</var></span>)</code></dt>
                <dd>
                  <p>This method retrieves and returns the part of the string value
          of the current instance that begins at index
          <i class="parameter"><tt>offset</tt></i> and extends
          <i class="parameter"><tt>count</tt></i> characters.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">deleteData</span>(<span class="methodparam"><var class="parameter">offset</var></span>, <span class="methodparam"><var class="parameter">count</var></span>)</code></dt>
                <dd>
                  <p>This method deletes the part of the string value of the
          current instance that begins at index <i class="parameter"><tt>offset</tt></i>
          and extends <i class="parameter"><tt>count</tt></i> characters.</p>
                </dd>
              </dl>
            </div>
            <p>A few DOM actions are not "owned" by any individual document. In
    effect, they are general-purpose operations. They can be found in
    <tt class="classname">DOMImplementation</tt> objects. One such precreated
    instance can be conveniently found at and used from
    <tt class="property">Ft.Xml.Domlette.implementation</tt>. The general methods
    that such a <tt class="classname">DOMImplementation</tt> object offers are
    listed below.</p>
            <div class="variablelist">
              <p class="title"><b>DOMImplementation methods:</b></p>
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">createDocument</span>(<span class="methodparam"><var class="parameter">namespaceURI</var></span>, <span class="methodparam"><var class="parameter">qualifiedName</var></span>, <span class="methodparam"><var class="parameter">doctype</var></span>)</code></dt>
                <dd>
                  <p>This standard DOM method creates and returns a
          <tt class="classname">Document</tt> object associated with the given
          <tt class="classname">DocumentTyype</tt> object, and having a single
          element child with the given QName and namespace. Since Domlette
          does not use <tt class="classname">DocumentTyype</tt> objects, the
          <i class="parameter"><tt>doctype</tt></i> argument must be given as <tt class="literal">None</tt>.
          </p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">createRootNode</span>(<span class="methodparam"><var class="parameter">documentURI</var></span>)</code></dt>
                <dd>
                  <p>This Domlette-specific method creates a
          <tt class="classname">Document</tt> object with the specified document
          (base) URI. No document element is created. This method is generally
          preferred over <tt class="methodname">createDocument</tt>(); see the
          following section, 'Building a DOM from scratch'.</p>
                </dd>
                <dt><code class="methodsynopsis"><span class="methodname">hasFeature</span>(<span class="methodparam"><var class="parameter">feature</var></span>, <span class="methodparam"><var class="parameter">version</var></span>)</code></dt>
                <dd>
                  <p>This method tests whether the DOM implementation implements a
          specific feature.</p>
                </dd>
              </dl>
            </div>
            <div class="section"><a id="id3057681324L" name="id3057681324L"></a>
              <div>
                <h3 class="title"><span class="section-number">3.2.1 </span>What about
      <tt class="methodname">getElementsByTagName</tt>()?</h3>
              </div>
              <p>The <tt class="methodname">getElementsByTagName</tt>() method isn't
      supported, because there are better options. In particular, you can just
      use XPath:</p>
              <div class="programlisting">
                <pre>doc.xpath(u"//tagname")</pre>
              </div>
              <p>For more possibilities, see <a href="http://uche.ogbuji.net/tech/akara/nodes/2004-06-19/get-elements"><tt class="methodname">getElementsByTagName</tt>
      Alternatives</a>.</p>
            </div>
          </div>
          <div class="section" id="domlette_serializing"><a id="domlette_serializing" name="domlette_serializing"></a>
            <div>
              <h2 class="title"><span class="section-number">3.3 </span>Serializing Domlette nodes</h2>
            </div>
            <p>Domlette comes with a couple of very fast printer functions which
    also go to great pains to correctly handle character encoding issues:
    <tt class="methodname">Print</tt> and <tt class="methodname">PrettyPrint</tt>.
    Here are some serialization examples using the Domlette printers, given a
    node '<tt class="literal">node</tt>' (it doesn't have to be a document
    node).</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import Print, PrettyPrint

# basic serialization to sys.stdout
Print(node)

# ... with extra whitespace (indenting)
PrettyPrint(node)

# ... using a single tab, rather than 2 spaces, to indent at each level
PrettyPrint(node, indent='\t')

# serializing to a utf-8 encoded file
f = open('output.xml','w')
Print(node, stream=f)
f.close()

# ... to an iso-8859-1 encoded file
f = open('output.xml','w')
Print(node, stream=f, encoding='iso-8859-1')
f.close()

# ... to an ascii encoded string
import cStringIO
buf = cStringIO.StringIO()
Print(node, stream=buf, encoding='us-ascii')
buf.close()
s = buf.getvalue()

# Normally, output syntax (XML or HTML) is chosen based on the DOM type,
# which is automatically detected. A Domlette or XML DOM can be output in
# HTML syntax if the asHtml=1 argument is given.
PrettyPrint(node, asHtml=1)</pre>
            </div>
            <p>See also: <i class="citetitle"><a href="http://uche.ogbuji.net/tech/akara/nodes/2003-01-01/dom-printing">Serializing
    XML from DOM or Domlette documents</a></i></p>
          </div>
          <div class="section"><a id="id3057682540L" name="id3057682540L"></a>
            <div>
              <h2 class="title"><span class="section-number">3.4 </span>Building a DOM from scratch</h2>
            </div>
            <p>As an alternative to parsing a preexisting XML document, you can
    also build a document model, with certain limitations, from the ground up.
    W3C and Python DOM facilities for doing this are intended mainly for creating
    a temporary document whose nodes will be imported into an existing document,
    and while Domlette does offer a more convenient document creation method,
    it has many of the same limitations. However, for most documents, its
    capabilities should be sufficient.</p>
            <p>The <tt class="systemitem">Ft.Xml.Domlette</tt> module
    contains a <tt class="classname">DOMImplementation</tt> instance named
    <tt class="property">implementation</tt> which provides a set of methods for
    initializing new <tt class="classname">Document</tt>s. The
    <tt class="methodname">implementation.createRootNode</tt> method takes a base URI
    argument and provides a natural approach for creating an XPath model root node.
    This is similar to the DOM idea of a document node and even closer to a DOM
    document fragment (multiple element children are allowed). The
    <tt class="methodname">implementation.createDocument</tt> method, on the
    other hand, is designed to come close to the DOM interface, although its
    doctype argument must be <tt class="literal">None</tt>.</p>
            <div class="programlisting">
              <pre>doc = implementation.createRootNode('file:///article.xml')</pre>
            </div>
            <p>is the equivalent of</p>
            <div class="programlisting">
              <pre>from Ft.Xml import EMPTY_NAMESPACE
doc = implementation.createDocument(EMPTY_NAMESPACE, None, None)</pre>
            </div>
            <p>with the added advantage of doc.baseURI being set to
    'file:///article.xml', which is not possible to set via standard DOM interfaces
    (the baseURI attribute is read-only).</p>
            <p>Similarly,</p>
            <div class="programlisting">
              <pre>from Ft.Xml import EMPTY_NAMESPACE
doc = implementation.createRootNode('file:///article.xml')
docelement = doc.createElementNS(EMPTY_NAMESPACE, 'article')
doc.appendChild(docelement)</pre>
            </div>
            <p>is the equivalent of</p>
            <div class="programlisting">
              <pre>from Ft.Xml import EMPTY_NAMESPACE
doc = implementation.createDocument(EMPTY_NAMESPACE, 'article', None)</pre>
            </div>
            <p>plus doc.baseURI being set to 'file:///article.xml'.</p>
            <p>If you want as much fidelity to the DOM API as Domlette offers, use
    <tt class="literal">implementation.createDocument</tt>. If you just want to
    create a document or other such root-level node, and never mind the
    strange parameters, use
    <tt class="methodname">implementation.createRootNode</tt>.</p>
          </div>
          <div class="section" id="xpath_query"><a id="xpath_query" name="xpath_query"></a>
            <div>
              <h2 class="title"><span class="section-number">3.5 </span>XPath query</h2>
            </div>
            <p>You can easily perform XPath queries by use the
    <tt class="methodname">xpath</tt> method for cDomlette nodes as
    follows:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import NonvalidatingReader
doc = NonvalidatingReader.parseString("&lt;spam&gt;eggs&lt;a/&gt;&lt;a/&gt;&lt;/spam&gt;")
print doc.xpath(u'//a')
print doc.xpath(u'string(/spam)')</pre>
            </div>
            <p>Notice: this is nothing like W3C DOM's XPath query module. The
    emphasis, as usual with Domlette, is on speed, simplicity and
    pythonic-ness.</p>
            <p>The API, in brief:</p>
            <p><tt class="literal">node.xpath(expr[, explicitNss])</tt></p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>node - will be used as core of the context for evaluating the
        XPath</p>
              </li>
              <li>
                <p>expr - XPath expression in string or compiled form</p>
              </li>
              <li>
                <p>explicitNss - (optional) any additional or overriding namespace
        mappings in the form of a dictionary that maps prefixes to namespace
        URIs. The base namespace mappings are taken from in-scope declarations
        on the given node. This explicit dictionary is superimposed on the
        base mappings.</p>
              </li>
            </ul>
            <p>For additional details, see <a href="#xpath_engine" title="XPath queries">&ldquo;XPath queries&rdquo;</a>.</p>
          </div>
          <div class="section"><a id="id3057693420L" name="id3057693420L"></a>
            <div>
              <h2 class="title"><span class="section-number">3.6 </span>More on base URIs</h2>
            </div>
            <p>For some users, always specifying a base URI feels like an
    inconvenience. Perhaps they always generate XML sources from text or
    streams without naturally associated URIs, and they have to figure out
    schemes to come up with base URIs for the parse. But there is good reason
    for this pickiness. Just ask one of the users <a href="http://lists.fourthought.com/pipermail/4suite/2004-January/006064.html">who
    got bitten by carelessness with base URIs in practice</a>. It's better
    to always put some amount of thought into base URIs when processing XML,
    and 4Suite encourages this.</p>
            <p>Note that 4Suite only enforces the requirement for base URIs in
    cases where they are needed to make sense of a requested operation. Your
    document must have a valid base URI if you use external entities,
    XInclude, xsl:import, xsl:include, the XSLT document() function, the EXSLT
    exsl:document element, or any other operations that require access to an
    external resource. If your main use for URI resolution is XSLT import and
    includes, you can avoid having to give valid base URIs by using XSLT
    include paths.</p>
            <p>A valid base URI starts with a scheme, such as
    <tt class="literal">http:</tt>. A simple name, such as "spam" is a valid
    relative URI reference, but not a valid base URI. Without a base URI, a
    relative reference is no more useful than an apartment number given
    without the address of the entire apartment building. Merging a base URI
    with a relative reference is a string operation that is undertaken in a
    standard manner, and is generally only useful when the base URI is
    hierarchical; that is, it is a URL using one of the common schemes that
    have slashes as path separators (e.g., http:, ftp:, gopher:, and most
    file: URLs). The built-in 4Suite URI resolver
    <tt class="systemitem">Ft.Lib.Uri.BASIC_RESOLVER</tt> knows
    how to perform such resolution.</p>
          </div>
          <div class="section"><a id="id3057693932L" name="id3057693932L"></a>
            <div>
              <h2 class="title"><span class="section-number">3.7 </span>Why does Domlette diverge from the DOM specification?</h2>
            </div>
            <p>Domlette is not a complete or fully conformant DOM implementation,
    but it does provide an interface very close to W3C DOM Level 2 and the
    corresponding Python mapping as laid out in the
    <tt class="systemitem">xml.dom</tt> API docs.
    </p>
            <p>The areas of divergence are inconsequential for most users,
    and generally reflect decisions made in the interest of eliminating
    redundancy, inefficiency, and, to some degree, un-Pythonic design.
    Also, one of the important design principles for Domlette is that
    where DOM and XPath disagree, XPath wins; aside from making things
    more efficient to implement, this behavior is generally what people
    want in an XML document model.</p>
            <p>It is also worth noting that in the interest of usability,
    all DOM implementations exhibit some degree of variation from the
    specs. Coding a completely implementation-agnostic DOM application
    is difficult and usually unnecessary.</p>
          </div>
        </div>
        <div class="section" id="saxlette"><a id="saxlette" name="saxlette"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">4 </span>SAX</h1>
          </div>
          <p>Saxlette is a fast SAX implementation, all written in C. Its API is
  similar to those of <a href="http://docs.python.org/lib/content-handler-objects.html">Python's
  built-in SAX</a>.</p>
          <div class="programlisting">
            <pre>from xml import sax
from Ft.Xml import CreateInputSource

class element_counter(sax.ContentHandler):
    def startDocument(self):
        self.ecount = 0

    def startElementNS(self, name, qname, attribs):
        self.ecount += 1

parser = sax.make_parser(['Ft.Xml.Sax'])
handler = element_counter()
parser.setContentHandler(handler)
#'file:ot.xml' or file('ot.xml') or file('ot.xml').read() would work just as well, of course
parser.parse(CreateInputSource('ot.xml'))
print "Elements counted:", handler.ecount</pre>
          </div>
          <p>If you don't care about PySax compatibility, you can use the more
  specialized API, which involves the following lines in place of the
  equivalents above:</p>
          <div class="programlisting">
            <pre>from <tt class="systemitem">Ft.Xml</tt> import <tt class="classname">Sax</tt>
...
class element_counter:
....
parser = Sax.CreateParser()</pre>
          </div>
          <p>The biggest API differences between Saxlette and PySax are that
  Saxlette only supports SAX 2. For example,
  <tt class="literal">feature_namespaces</tt> is hard-wired to
  <tt class="literal">True</tt> and <tt class="literal">feature_namespace_prefixes</tt> to
  <tt class="literal">False</tt> (which is exactly what SAX2 says is required).
  Saxlette also combines all adgacent text events, which eliminates one of the
  pain points of PySax.</p>
          <p>The argument to the <tt class="function">parse</tt> method is a URI, a SAX
  input source or a 4Suite input source. In the example above a URI was used.
  The following example shows similar code using 4Suite's <tt class="systemitem">Ft.Xml.InputSource</tt>.</p>
          <div class="programlisting">
            <pre>from Ft.Xml import InputSource, Sax
factory = InputSource.DefaultFactory
isrc = factory.fromUri("file:ot.xml")
doc1 = NonvalidatingReader.parse(isrc)

class element_counter:
    def startDocument(self):
        self.ecount = 0

    def startElementNS(self, name, qname, attribs):
        self.ecount += 1

parser = Sax.CreateParser()
handler = element_counter()
parser.setContentHandler(handler)
parser.parse(isrc)
print "Elements counted:", handler.ecount</pre>
          </div>
          <div class="section"><a id="id3057695084L" name="id3057695084L"></a>
            <div>
              <h2 class="title"><span class="section-number">4.1 </span>Validating a document while parsing it using SAX</h2>
            </div>
            <p>To enable validation of your documents while otherwise parsing them
    normally with SAX, set the
    <tt class="constant">xml.sax.handler.feature_validation</tt> feature to
    <tt class="literal">True</tt> on your parser using a line similar to
    <tt class="code">parser.setFeature(xml.sax.handler.feature_validation, True)</tt>.
    The parser will then throw an
    <tt class="classname">xml.sax._exceptions.SAXParseException</tt> exception if
    it determines that the document is invalid, and it will stop parsing the
    document. Handlers for document components that have been parsed will be
    called, however. The following example illustrates these concepts.</p>
            <div class="programlisting">
              <pre>from Ft.Xml import InputSource, Sax
factory = InputSource.DefaultFactory

XML = """&lt;!DOCTYPE a [
  &lt;!ELEMENT a (b, b)&gt;
  &lt;!ELEMENT b EMPTY&gt;
]&gt;
&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;/a&gt;"""

isrc = factory.fromString(XML, 'urn:x-example:valid-a')

class element_counter:
    def startDocument(self):
        self.scount = 0
        self.ecount = 0

    def startElementNS(self, name, qname, attribs):
        self.scount += 1

    def endElementNS(self, name, qname):
        self.ecount += 1

parser = Sax.CreateParser()
handler = element_counter()
parser.setContentHandler(handler)
# And now, to enable validation...
import xml
parser.setFeature(xml.sax.handler.feature_validation, True)
parser.parse(isrc)
print "Saw", handler.scount, "start tags"
print "Saw", handler.ecount, "end tags"

# And now we show what happens on an invalid document:
XML = """&lt;!DOCTYPE a [
  &lt;!ELEMENT a (b, b)&gt;
  &lt;!ELEMENT b EMPTY&gt;
]&gt;
&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;b/&gt;&lt;/a&gt;"""

isrc = factory.fromString(XML, 'urn:x-example:invalid-a')
parser.parse(isrc)
print "Saw", handler.scount, "start tags"
print "Saw", handler.ecount, "end tags"
# The above document is invalid; it has one more `b` element than is
# allowed by the DTD.  The handlers have still been called for those
# parts of the document that have been parsed.</pre>
            </div>
          </div>
          <div class="section" id="saxlette_domwalker"><a id="saxlette_domwalker" name="saxlette_domwalker"></a>
            <div>
              <h2 class="title"><span class="section-number">4.2 </span>Walking a DOM to fire SAX events</h2>
            </div>
            <p>Saxlette has the ability to walk a Domlette tree, firing off events
    to a handler as if from a source document parse. This ability used to be
    too well, hidden, though, and I made an API addition to make it more
    readily available. This is the new
    <tt class="classname">Ft.Xml.Domlette.SaxWalker</tt>. The following example
    should show how easy it is to use:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import SaxWalker
from Ft.Xml import Parse

XML = "&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;/a&gt;"

class element_counter:
    def startDocument(self):
        self.ecount = 0

    def startElementNS(self, name, qname, attribs):
        self.ecount += 1

#First get a Domlette document node
doc = Parse(XML)
#Then SAX "parse" it
parser = SaxWalker(doc)
handler = element_counter()
parser.setContentHandler(handler)
#You can set any properties or features, or do whatever
#you would to a regular SAX2 parser instance here
parser.parse() #called without any argument
print "Elements counted:", handler.ecount</pre>
            </div>
          </div>
          <div class="section" id="saxlette_dombuilder"><a id="saxlette_dombuilder" name="saxlette_dombuilder"></a>
            <div>
              <h2 class="title"><span class="section-number">4.3 </span>Building a Domlette from SAX events</h2>
            </div>
            <p>Saxlette includes a convenience ContentHandler
    (<tt class="classname">Ft.Xml.Sax.DomBuilder</tt>) which listens for SAX
    events and constructs Domlette Documents.</p>
          </div>
          <div class="section" id="saxlette_generator"><a id="saxlette_generator" name="saxlette_generator"></a>
            <div>
              <h2 class="title"><span class="section-number">4.4 </span>Feeding a generator from SAX events</h2>
            </div>
            <p>Python's generators are special functions that can produce a series
    of partial results within the course of running. The calling program can
    start up a generator, which is suspended when a partial result is yielded,
    and resumed explicitly by the program when the next result is required.
    This capability is mirrored in the Expat parser that is the basis of
    Saxlette. Saxlette has a feature, <tt class="literal">FEATURE_GENERATOR</tt>
    which you can set on a parser object to enable generator semantics. If
    this feature is set, the <tt class="literal">parse()</tt> method returns an
    iterator. This iterator yields results set by the the SAX handlers. The
    handlers specify the partial results by setting the property
    <tt class="literal">PROPERTY_YIELD_RESULT</tt> with the value to be yielded. As
    an example, the following code reports the name of all attributes used in
    the document.</p>
            <div class="programlisting">
              <pre>class report_attributes:
    def __init__(self, parser):
        self.parser = parser
        return

    def startElementNS(self, name, qname, attribs):
        self.parser.setProperty(Sax.PROPERTY_YIELD_RESULT, attribs)
        return

from Ft.Xml import Sax, CreateInputSource

parser = Sax.CreateParser()
parser.setFeature(Sax.FEATURE_GENERATOR, True)
handler = report_attributes(parser)
parser.setContentHandler(handler)
attribs_iterator = parser.parse(CreateInputSource('test.xhtml'))
for attribs in attribs_iterator:
     for name in attribs.keys(): print name</pre>
            </div>
          </div>
          <div class="section"><a id="id3057696684L" name="id3057696684L"></a>
            <div>
              <h2 class="title"><span class="section-number">4.5 </span>SAX filters</h2>
            </div>
            <p>In SAX processing, the parser passes to the application a stream of events that represents the XML content. An important aspect of SAX is the user's ability to create SAX filters, which accept a stream of SAX events and pass on a modified stream. For example, you might use a SAX filter to take look for DOcbook <tt class="literal">sect1</tt>,  <tt class="literal">sect2</tt> etc. elements, and rename them to <tt class="literal">section</tt> elements before passing them on for further processing (presumably by a SAX handler that only understands how to deal with the latter form).  You can chain SAX filters as well, and the idea behind SAX filters is usually reuse across a broad array of applications, focusing each filter they on a single task that can be cleanly separated from upstream and downstream processing.  SAX filters can thus be useful building blocks for XML pipelines.</p>
            <div class="programlisting">
              <pre>from xml import sax
from xml.sax.saxutils import XMLFilterBase
from Ft.Xml import CreateInputSource, XML_NAMESPACE as XMLNS
from Ft.Xml.Sax import SaxPrinter

XML = """&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;menu&gt;
  &lt;item id="A" xml:lang="en"&gt;Orange juice&lt;/item&gt;
  &lt;item id="A" xml:lang="es"&gt;Jugo de naranja&lt;/item&gt;
  &lt;item id="B" xml:lang="en"&gt;Toast&lt;/item&gt;
  &lt;item id="B" xml:lang="es"&gt;Pan tostada
    &lt;note xml:lang="en"&gt;Wheat bread only, please&lt;/note&gt;
  &lt;/item&gt;
&lt;/menu&gt;
"""

#Define constants for the two states we care about
ALLOW_CONTENT = 1
SUPPRESS_CONTENT = 2

class english_only_filter(XMLFilterBase):
    def __init__(self, downstream):
        XMLFilterBase.__init__(self, downstream)
        return

    def startDocument(self):
        #Set the initial state, and set up the stack of states
        self._state_stack = [ALLOW_CONTENT]
        XMLFilterBase.startDocument(self)
        return

    def startElementNS(self, name, qname, attrs):
        #Check if there is any language attribute
        lang = attrs.get((XMLNS, 'lang'))
        if lang:
            #Set the state as appropriate
            if lang[:2] == 'en':
	        self._state_stack.append(ALLOW_CONTENT)
            else:
	        self._state_stack.append(SUPPRESS_CONTENT)
        #Always update the stack with the current state
        #Even if it has not changed
        
        #Only forward the event if the state warrants it
        if self._state_stack[-1] == ALLOW_CONTENT:
            XMLFilterBase.startElementNS(self, name, qname, attrs)
        return

    def endElementNS(self, name, qname):
        self._state_stack.pop()
        #Only forward the event if the state warrants it
        if self._state_stack[-1] == ALLOW_CONTENT:
            XMLFilterBase.endElementNS(self, name, qname)
        return

    def characters(self, content):
        #Only forward the event if the state warrants it
        if self._state_stack[-1] == ALLOW_CONTENT:
            XMLFilterBase.characters(self, content)
        return

if __name__ == "__main__":
    parser = sax.make_parser(['Ft.Xml.Sax'])
    #SaxPrinter is a special SAX handler that merely writes
    #SAX events back into an XML document
    filtered_parser = english_only_filter(parser)
    handler = SaxPrinter()
    filtered_parser.setContentHandler(handler)
    filtered_parser.parse(CreateInputSource(XML))
</pre>
            </div>
            <p>Most SAX handlers operate as state machines, meaning they manage some variables based on the stream of events that come in, and change behavior based on these variables. english_only_filter is set up to be in one of two states: one in which content is passed on to the downstream handler, and one in which content is suppressed. This state is marked in the self._state_stack. The state is initially set to <tt class="literal">ALLOW_CONTENT</tt>, and changed to <tt class="literal">SUPPRESS_CONTENT</tt> if the filter encounters an xml:lang attribute that represents a language other than English (which can be done by checking the first two characters of the value, according to the rules of standard language codes).  It has to be a stack because XML language specifications are scoped, so that in the example XML at the top of the listing the string "Pan tostada" is within the scope of the element with the attribute xml:lang="es", and so it is marked as being in Spanish. The entire note element, however, is marked as being in English by an overriding xml:lang="en" attribute.</p>
            <p>The SAX handler is set to <tt class="classname">Ft.Xml.SaxPrinter</tt>, which channels the final SAX evenis onto a 4Suite printer which creates a serialized XML document.  It's quite easy to chain filters.  If you wanted the parser to send events to a filter of class <tt class="classname">some_other_filter</tt> which then passed on events to <tt class="classname">english_only_filter</tt> the relevant line would look as follows:</p>
            <div class="programlisting">
              <pre>    filtered_parser = english_only_filter(some_other_filter(parser))
</pre>
            </div>
          </div>
          <div class="section"><a id="id3057705900L" name="id3057705900L"></a>
            <div>
              <h2 class="title"><span class="section-number">4.6 </span>Streaming canonicalization</h2>
            </div>
            <p>The combination of streaming parsing using Saxlette and streaming serialization using <tt class="classname">Ft.Xml.Lib.CanonicalXmlPrinter</tt> allows for
very efficient XML canonicalization (c14n).
</p>
            <p></p>
            <div class="programlisting">
              <pre>import sys
from xml import sax
from Ft.Xml import CreateInputSource
from Ft.Xml.Sax import SaxPrinter
from Ft.Xml.Lib.XmlPrinter import CanonicalXmlPrinter

parser = sax.make_parser(['Ft.Xml.Sax'])
handler = SaxPrinter(CanonicalXmlPrinter(sys.stdout))
parser.setContentHandler(handler)
parser.parse(CreateInputSource('   &lt;a&gt;&lt;b b="1" a="2"/&gt;&lt;/a&gt;   '))

</pre>
            </div>
          </div>
        </div>
        <div class="section" id="xpath_engine"><a id="xpath_engine" name="xpath_engine"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">5 </span>XPath queries</h1>
          </div>
          <p>4Suite provides an XPath processing engine, compliant with <a href="http://www.w3.org/TR/xpath">the W3C XPath 1.0 specification</a>.
  This query engine is accessible through <tt class="systemitem">Ft.Xml.XPath</tt>.</p>
          <div class="section" id="xpath_quick"><a id="xpath_quick" name="xpath_quick"></a>
            <div>
              <h2 class="title"><span class="section-number">5.1 </span>The quickest option</h2>
            </div>
            <p>If you are using Domlette, as described above, the quickest and
    easiest way to use the XPath facility in 4Suite is the
    <tt class="methodname">xpath()</tt> method, which any Domlette
    <tt class="classname">Node</tt> supports:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import NonvalidatingReader
doc = NonvalidatingReader.parseString("&lt;spam&gt;eggs&lt;a/&gt;&lt;a/&gt;&lt;/spam&gt;")
doc2 = NonvalidatingReader.parseString("&lt;spam&gt;eggs&lt;eggs n='1'&gt; and ham&lt;/eggs&gt;&lt;/spam&gt;")
print doc.xpath(u'(//a)[1]')
print doc.xpath(u'string(/spam)')
print doc2.xpath(u'string(//eggs/@n)')</pre>
            </div>
            <p>The line</p>
            <div class="programlisting">
              <pre>print doc.xpath(u'(//a)[1]')</pre>
            </div>
            <p>Is actually a shortcut for the following more involved construct,
    which is described in detail in the next section:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.XPath import Evaluate
print Evaluate(u'(//a)[1]', contextNode=doc)</pre>
            </div>
            <p>This example prints three lines. The first line shows a string
    representation of a list containing a single element. As we see from this
    line, an XPath selection of nodes returns a Python list. In this case, it
    is a list containing a single element&mdash;the first element with a local name
    of <tt class="sgmltag">a</tt>, which has no attributes and no
    children. The second line shows the correct string value of the selected
    <tt class="sgmltag">spam</tt> element, and the third line shows
    the correct string value of the <tt class="sgmltag">n</tt>
    attribute.</p>
            <div class="screen">
              <pre>[&lt;Element at 0xb7d10bb4: name u'a', 0 attributes, 0 children&gt;]
eggs
1</pre>
            </div>
          </div>
          <div class="section" id="typeMap"><a id="typeMap" name="typeMap"></a>
            <div>
              <h2 class="title"><span class="section-number">5.2 </span>Type mappings</h2>
            </div>
            <p>4Suite XPath functions return results with Python types that depend
    on the XPath data model type of the query result. The following list shows
    how the five XPath result types (String, number, boolean, node-set and
    object) are mapped to Python types:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>XPath string: Python unicode type</p>
              </li>
              <li>
                <p>XPath number: Python float type (int or long also accepted), or
        instance of Ft.Lib.number.nan (for NaN) or Ft.Lib.number.inf (for
        Infinity)</p>
              </li>
              <li>
                <p>XPath boolean: Ft.Lib.boolean instance</p>
              </li>
              <li>
                <p>XPath node-set: Python list of Domlette nodes, in document
        order, with no duplicates</p>
              </li>
              <li>
                <p>XPath foreign object: any other Python object (you will very
        rarely encounter this case)</p>
              </li>
            </ul>
          </div>
          <div class="section"><a id="id3057708396L" name="id3057708396L"></a>
            <div>
              <h2 class="title"><span class="section-number">5.3 </span>Advanced use</h2>
            </div>
            <p>XPath expressions can refer to both variables and qualified names
    (QNames) that must be defined by the environment that is executing the
    XPath expression. This section describes how to use these advanced
    features of XPath using the 4Suite interface.</p>
            <p>4Suite's XPath implementation uses a Domlette node as the context
    node for XPath operations. The following example demonstrates the use of
    XPath to extract content from an XML document. The document must be parsed
    before Xpath can be used to access it. The following example parses the
    XML document and explicitly sets up an XPath context to run an XPath
    query.</p>
            <div class="programlisting">
              <pre>XML = """
&lt;ham&gt;
&lt;eggs n='1'/&gt;
This is the string content with &lt;em&gt;emphasized text&lt;/em&gt; text
&lt;/ham&gt;"""

from Ft.Xml import Parse
from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Evaluate

doc = Parse(XML)
ctx = Context(doc)
nodes = Evaluate(u'//em', ctx)

# The return value, a node set, comes back as a Python list of nodes
# which may be accessed using an iterator
for n in nodes:
    # print dir(n)
    print n.tagName
    print n.firstChild.nodeValue</pre>
            </div>
            <p>XPath always requires a context for execution; a common XPath
    context is the root of the target document, such as we did in the above
    example. Think about an XPath query being executed from some location in
    an XML document. This location in the document is a necessary component of
    using XPath.</p>
            <p>There is more to an XPath context than just the context node, but if
    your needs are as straightforward as that of the above example, there is
    an abbreviated version of the <tt class="methodname">Evaluate</tt> method for
    this purpose. For example, the following fragment is equivalent to the two
    lines creating a context and evaluating the expression in the above
    example.</p>
            <div class="programlisting">
              <pre># No need to create a context object
Evaluate(u'//em', contextNode=doc)</pre>
            </div>
            <p>If your source document uses XML Namespaces you will likely need to
    use QNames in your XPath expressions. For this to work, you'll need to
    introduce namespace mappings into your XPath context. For example, if the
    elements of our XML document above are in an XML namespace, then we must
    set up our context slightly differently.</p>
            <div class="programlisting">
              <pre>XML = """&lt;ham xmlns="http://example.com/ns#"&gt;
&lt;eggs n='1'/&gt;
This is the string content with &lt;em type='bold'&gt;emphasized Namespaced Text&lt;/em&gt; text
&lt;/ham&gt;"""

from Ft.Xml import Parse
from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Evaluate

NSS = {u'ex': u'http://example.com/ns#'}
doc = Parse(XML)
ctx = Context(doc, processorNss=NSS)
nodes = Evaluate(u'//ex:em', ctx)
for n in nodes:
    # print dir(n)
    print n.tagName
    print n.firstChild.nodeValue</pre>
            </div>
            <p>You define XPath namespace prefixes through a Python dictionary
    (<tt class="varname">NSS</tt> in the above example) which maps these prefixes,
    such as '<tt class="literal">ex</tt>' in the above example, to the appropriate
    namespace URI, such as '<tt class="literal">http://example.com/ns#</tt>' in the
    above example. This prefix mapping is added to your XPath context using
    the <i class="parameter"><tt>processorNss</tt></i> parameter to the
    <tt class="function">Context</tt> function.</p>
            <p>In a similar way, you can also pass in variable bindings which may
    be used as values later in your XPath expressions. In this case, however,
    variables are Python tuples containing the namespace URI and local name of
    the variable.</p>
            <div class="programlisting">
              <pre>ctx = Context(node, varBindings=
  {(EMPTY_NAMESPACE, u'date'): u'2003-06-20'})
Evaluate('event[@date = $date]', context=ctx)</pre>
            </div>
            <p>This creates a variable in the default namespace named 'date', with
    a value of '<tt class="literal">2003-06-20</tt>'; this is then used for
    comparison with the date attribute in the Xpath expression.</p>
            <p>XPath variables are Qnames, so you pass in variable names as
    namespace/local name tuples. The values can be numbers, unicode objects or
    boolean objects:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.XPath import boolean
ctx = Context(node, varBindings={(EMPTY_NAMESPACE, u'test'): boolean.true})</pre>
            </div>
            <p>This sets the variable 'test' to the boolean value true (remember
    that this is for the XPath environment, not the Python one), and again
    this may be used as in any XSLT stylesheet.</p>
            <p>If you only want a value once, you may of course still use string
    constants, as in</p>
            <div class="programlisting">
              <pre>nodes=Evaluate(u'//testPrefix:em[@type="bold"]',ctx)</pre>
            </div>
            <p>Note the quotes used? These must be balanced, hence the literal
    value uses double quotes.</p>
          </div>
          <div class="section"><a id="id3057722476L" name="id3057722476L"></a>
            <div>
              <h2 class="title"><span class="section-number">5.4 </span>Reusing parsed XPath queries</h2>
            </div>
            <p>Sometimes you want to re-use an XPath expression and namespace
    mapping multiple times, for efficiency and convenience. The following
    example shows an example of this:</p>
            <div class="programlisting">
              <pre>from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Compile, Evaluate
from Ft.Xml import Parse

DOCS = ["&lt;spam xmlns='http://spam.com'&gt;eggs&lt;/spam&gt;",
        "&lt;spam xmlns='http://spam.com'&gt;grail&lt;/spam&gt;",
        "&lt;spam xmlns='http://spam.com'&gt;nicht&lt;/spam&gt;",
       ]

# Pre-compile for efficiency and convenience
expr = Compile(u"/a:spam[contains(., 'i')]")
ctx = Context(None, processorNss={u"a": u"http://spam.com"})

i = 1
for doc in DOCS:
    doc = NonvalidatingReader.parseString(doc.encode('UTF-8'),
                                          "http://spam.com/base")
    retval = Evaluate(expr, doc, ctx)
    if len(retval):
        print "Document", i, "meets our criteria"
    i += 1</pre>
            </div>
            <p>Which should display:</p>
            <div class="screen">
              <pre>Document 2 meets our criteria
Document 3 meets our criteria</pre>
            </div>
          </div>
          <div class="section"><a id="id3057722860L" name="id3057722860L"></a>
            <div>
              <h2 class="title"><span class="section-number">5.5 </span>Migration from PyXML's XPath</h2>
            </div>
            <p>There is a usable XPath module in PyXML (warning: PyXML's XSLT
    implementation is not usable: use 4Suite if you need XSLT), but there are
    a lot of updates and improvements in the XPath library version in
    4Suite.</p>
            <p>If you are familiar with PyXML, you may have used a different form
    of imports to load in XPath and XSLT features. The imports are different
    under 4Suite.</p>
            <p>Usage example:</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>PyXML usage (do not use with 4Suite):</p>
                <div class="programlisting">
                  <pre>import xml.xslt
import xml.xpath</pre>
                </div>
              </li>
              <li>
                <p>4Suite usage (use these imports):</p>
                <div class="programlisting">
                  <pre>import Ft.Xml.XPath
import Ft.Xml.Xslt</pre>
                </div>
              </li>
            </ol>
          </div>
        </div>
        <div class="section" id="xslt_engine"><a id="xslt_engine" name="xslt_engine"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">6 </span>XSLT processing</h1>
          </div>
          <div class="section" id="simple_xslt_api"><a id="simple_xslt_api" name="simple_xslt_api"></a>
            <div>
              <h2 class="title"><span class="section-number">6.1 </span>The super-simple XSLT API</h2>
            </div>
            <p>For basic XSLT transform needs, or to get started quickly, the
    <tt class="systemitem">Ft.Xml.Xslt</tt> module offers a quick
    way to apply transforms XML documents and get back the simple string
    result. Within this module, the function of interest is
    <tt class="function">Transform</tt>.</p>
            <div class="variablelist">
              <dl>
                <dt><code class="methodsynopsis"><span class="methodname">Transform</span>(<span class="methodparam"><var class="parameter">fname_or_uri</var></span>, <span class="methodparam"><var class="parameter">string_stream_fname_uri_isrc</var></span>, <span class="methodparam"><var class="parameter">[param]</var></span>, <span class="methodparam"><var class="parameter">[output]</var></span>)</code></dt>
                <dd>
                  <p>The <tt class="function">Transform</tt> function takes two
          arguments, with an optional third. The first is the source XML for the transform. The
          second is the XSLT document.  Both are given as a string, an object like an
          open file, a local file path on your computer, an absolute URI, or
          an InputSource object.  The optional <i class="parameter"><tt>params</tt></i> is a dictionary of stylesheet parameters, the keys of
             which may be given as unicode objects if they have no namespace,
             or as (uri, localname) tuples if they do.  The values are the overriden parameter values. If you do not supply the optional <i class="parameter"><tt>output</tt></i> parameter the return value is a string with the result
          of this transform.  If you do supply this parameter it must be a file-like object to which the output will be written, and then the return value is None.</p>
                </dd>
              </dl>
            </div>
            <div class="programlisting">
              <pre>XML = """
&lt;ham&gt;
&lt;eggs n='1'/&gt;
This is the string content with &lt;em&gt;emphasized text&lt;/em&gt; text
&lt;/ham&gt;"""

from Ft.Xml.Xslt import Transform
# URL for the identity transform: reproduces the input XML in the result
ID_TRANSFORM = 'http://cvs.4suite.org/viewcvs/*checkout*/4Suite/Ft/Data/identity.xslt'

result = Transform(XML, ID_TRANSFORM)
print result

# If the above XML document were located in the file
# "target.xml", we could have used `Transform("target.xml", ID_TRANSFORM)`.

#It's more efficient to redirect the processor output to an output stream.  The following does so:
import sys
result = Transform(XML, ID_TRANSFORM, output=sys.stdout)
print result</pre>
            </div>
          </div>
          <div class="section" id="full_XSLT_API"><a id="full_XSLT_API" name="full_XSLT_API"></a>
            <div>
              <h2 class="title"><span class="section-number">6.2 </span>Full XSLT processing API</h2>
            </div>
            <p>Here is the general procedure for using the Python API for XSLT
    processing:</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>Create an <tt class="classname">Ft.Xml.Xslt.Processor.Processor</tt>
        instance.</p>
              </li>
              <li>
                <p>Prepare <tt class="classname">Ft.Xml.InputSource</tt> instances (via
        their factory) for the source XML and stylesheet.</p>
              </li>
              <li>
                <p>Call the Processor's <tt class="methodname">appendStylesheet</tt>
        method, passing it the stylesheet's
        <tt class="classname">InputSource</tt>.</p>
              </li>
              <li>
                <p>Call the Processor's <tt class="methodname">run</tt> method,
        passing it the source document's
        <tt class="classname">InputSource</tt>.</p>
              </li>
            </ol>
            <p>For input to our transform, we will use the namespaced example as in
    the last section.</p>
            <div class="screen">
              <pre>$ cat testNS.xml
&lt;ham xmlns="http://example.com/ns#"&gt;
&lt;eggs n='1'/&gt;
This is the string content with
 &lt;em type='bold' f='2'&gt;emphasized Namespaced Text&lt;/em&gt;
text
&lt;/ham&gt;</pre>
            </div>
            <p>For our stylesheet, we will again use one of the simplest useful
    examples, the identity stylesheet.</p>
            <div class="screen">
              <pre>$ cat identity.xsl
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
            </div>
            <p>The code below follows the processing outline, having converted the
    input file and stylesheet to the URI format.</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Xslt import Processor
# We use the InputSource architecture
from Ft.Xml import InputSource
from Ft.Lib.Uri import OsPathToUri  # path to URI conversions

processor = Processor.Processor()

# Prepare an InputSource for the source document
# Convert from local file to uri
srcAsUri = OsPathToUri('testNS.xml')
source = InputSource.DefaultFactory.fromUri(srcAsUri)

# Prepare an InputSource for the stylesheet
# Convert from local file to uri
ssAsUri = OsPathToUri('identity.xsl')
transform = InputSource.DefaultFactory.fromUri(ssAsUri)

processor.appendStylesheet(transform)
result = processor.run(source)

# result is a string with the serialized transform result
print result</pre>
            </div>
            <p>You can call <tt class="methodname">run</tt> multiple times on
    different <tt class="classname">InputSource</tt>s. When you're done, the
    processor's <tt class="methodname">reset</tt> method can be used to restore a
    clean slate (at which point you would have to append stylesheets to the
    processor again).</p>
            <p>The following example uses our <tt class="varname">processor</tt> from the
    previous example to transform a new XML document, this one constructed
    manually.</p>
            <div class="programlisting">
              <pre>XML = """&lt;foo&gt;&lt;bar/&gt;&lt;/foo&gt;"""
source = InputSource.DefaultFactory.fromString(XML, 'http://example.org/foo')

result = processor.run(source)

# result is a string with the serialized transform result
print result</pre>
            </div>
            <p>This code continues from the previous example to process the second
    document, using the same <tt class="varname">processor</tt> and stylesheet. This
    is a useful form when there is a requirement for server side processing of
    multiple input documents with a common stylesheet.</p>
          </div>
          <div class="section"><a id="id3057731820L" name="id3057731820L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.3 </span>Example</h2>
            </div>
            <p>In the example below, strings are used as the source of the
    transform (stylesheet) and source documents, and we are careful to pass in
    a URI to identify each of them. In the source document, the URI is needed
    for resolving external entity references and XIncludes. In the stylesheet,
    the URI is needed for resolving <tt class="function">document</tt> function
    calls, <tt class="sgmltag">xsl:include</tt>s and <tt class="sgmltag">xsl:import</tt>s.</p>
            <p>If you do not provide a URI and you attempt to use any of these
    features, you may get an exception.</p>
            <div class="programlisting">
              <pre># The identity transform: duplicates the input to output
TRANSFORM = """
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

SOURCE = """&lt;spam id="eggs"&gt;I don't like spam&lt;/spam&gt;"""

# The processor class is the core of the XSLT API
from Ft.Xml.Xslt import Processor
processor = Processor.Processor()

# We use the InputSource architecture
from Ft.Xml import InputSource

# Prepare an InputSource for the transform
transform = InputSource.DefaultFactory.fromString(TRANSFORM,
  "http://spam.com/identity.xslt")

# Prepare an InputSource for the source document
source = InputSource.DefaultFactory.fromString(SOURCE,
  "http://spam.com/doc.xml")
processor.appendStylesheet(transform)
result = processor.run(source)

# result is a string with the serialized transform result
print result</pre>
            </div>
          </div>
          <div class="section"><a id="id3057732332L" name="id3057732332L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.4 </span>Using Domlette objects instead of InputSources</h2>
            </div>
            <p>If your documents are already in the form of Domlette documents, you
    don't need to create <tt class="classname">InputSource</tt>s for them; you can
    just use the <tt class="classname">Processor</tt>'s
    <tt class="methodname">appendStylesheetNode</tt> and
    <tt class="methodname">runNode</tt> methods instead of
    <tt class="methodname">appendStylesheet</tt> and
    <tt class="methodname">run</tt>, respectively.</p>
            <div class="note"><span class="label">Note</span>
              <p>It is usually slower to read the stylesheet from a Domlette object
      than to parse a serialized document.</p>
            </div>
            <div class="note"><span class="label">Note</span>
              <p>The Domlette documents used in the following example are obtained
      by parsing existing XML, but this approach can just as easily be used on
      Domlette documents that are built programmatically (i.e. using the DOM
      API).</p>
            </div>
            <div class="programlisting">
              <pre># The identity transform: duplicates the input to output
TRANSFORM = """
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;

  &lt;xsl:template match="@*|node()"&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:apply-templates select="@*|node()"/&gt;
    &lt;/xsl:copy&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

SOURCE = """&lt;spam id="eggs"&gt;I don't like spam&lt;/spam&gt;"""

from Ft.Xml.Xslt import Processor
processor = Processor.Processor()
from Ft.Xml.Domlette import NonvalidatingReader

# Create a DOM for the transform
transform = NonvalidatingReader.parseString(TRANSFORM,
  "http://spam.com/identity.xslt")

# Create a DOM for the source document
source = NonvalidatingReader.parseString(SOURCE, "http://spam.com/doc.xml")
processor.appendStylesheetNode(transform, "http://spam.com/identity.xslt")
result = processor.runNode(source, "http://spam.com/doc.xml")
print result</pre>
            </div>
            <p>If you have objects from another DOM library, you can first convert
    them to Domlette objects as shown in <a href="#converting_DOM" title="Converting from other DOM libraries">&ldquo;Converting from other DOM libraries&rdquo;</a>.</p>
          </div>
          <div class="section"><a id="id3057733356L" name="id3057733356L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.5 </span>Top-level parameters
                <br><span class="subtitle">Passing parameters to a stylesheet</span></h2>
            </div>
            <p>You can pass in stylesheet parameters as a Python dictionary. Use
    the parameter names for keys. Values use the 4Suite XPath library's
    standard type mappings, which are described in <a href="#typeMap" title="Type mappings">&ldquo;Type mappings&rdquo;</a>.</p>
            <p>Parameter and variable names in XPath/XSLT are actually
    expanded-names, which we represent as (namespaceURI, localName) tuples. If
    your parameter name is in a namespace, you have to use a tuple as the
    mapping key. Otherwise, you may simply use a unicode string that
    represents the local-name part only
    (<tt class="constant">Ft.Xml.EMPTY_NAMESPACE</tt> is the default
    namespace).</p>
            <p>Here is an example, which passes in the computed "date" parameter to
    the stylesheet from the program:</p>
            <div class="programlisting">
              <pre>SRC = """&lt;?xml version="1.0"?&gt;&lt;dummy/&gt;"""

STY = """&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:param name="date" select="'unknown'"/&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="us-ascii"/&gt;

    &lt;xsl:template match="/"&gt;
      &lt;result&gt;
        &lt;xsl:value-of select="$date"/&gt;
      &lt;/result&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

from Ft.Xml import InputSource
from Ft.Xml.Xslt import Processor
import time
src_isrc = InputSource.DefaultFactory.fromString(SRC, 'http://foo/dummy.xml')
sty_isrc = InputSource.DefaultFactory.fromString(STY, 'http://foo/dummy.xsl')

proc = Processor.Processor()
proc.appendStylesheet(sty_isrc)
params = {u'date': unicode(time.asctime())}
result = proc.run(src_isrc, topLevelParams=params)
print result</pre>
            </div>
          </div>
          <div class="section"><a id="id3057738092L" name="id3057738092L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.6 </span>Using xml-stylesheet processing instructions</h2>
            </div>
            <p>4Suite honors the <a href="http://www.w3.org/TR/xml-stylesheet/">Associating Stylesheets with
    XML Documents</a> W3C Recommendation and <a href="http://www.faqs.org/rfcs/rfc3023.html">RFC 3023: XML Media
    Types</a>. Instead of (or in addition to) using the processor's
    explicit APIs to establish the stylesheet to be used for the
    transformation, the source document may contain an xml-stylesheet
    processing instruction (PI) that refers to a stylesheet via a URI
    reference.</p>
            <p>The xml-stylesheet PI must meet the following criteria:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>It must appear in the document prolog.</p>
              </li>
              <li>
                <p>It must contain a "type" pseudo-attribute having one of the
        following values: 
                  <ul style="list-style-type: disc; list-style-position: outside;">
                    <li>
                      <p>application/xslt+xml</p>
                    </li>
                    <li>
                      <p>application/xslt</p>
                    </li>
                    <li>
                      <p>text/xml</p>
                    </li>
                    <li>
                      <p>application/xml</p>
                    </li>
                  </ul>
                </p>
              </li>
              <li>
                <p>It must contain an "href" pseudo-attribute that is a URI
        reference for the stylesheet. It will be resolved relative to the base
        URI of the source document that contains the xml-stylesheet PI.</p>
              </li>
            </ul>
            <p>This example shows a PI being used to refer to the identity
    stylesheet mentioned earlier</p>
            <div class="programlisting">
              <pre>&lt;?xml-stylesheet type="application/xslt" href="identity.xsl"?&gt;</pre>
            </div>
            <p>If you need to add to the supported media types, e.g., to add the
    nonstandard "text/xsl", then follow the example given in <a href="http://mail.python.org/pipermail/xml-sig/2004-January/010090.html">this
    mailing list message</a>.</p>
            <p>If the PI contains "alternate" and "media" pseudo-attributes, the
    package will do its best to handle them. See <a href="http://lists.fourthought.com/pipermail/4suite/2003-September/012218.html">this
    message</a> for details and examples.</p>
          </div>
          <div class="section"><a id="id3057739884L" name="id3057739884L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.7 </span>Alternative output destinations</h2>
            </div>
            <p>Normally, the processor buffers all output, then returns it as a
    byte string. If you want to write directly to some other stream (any
    Python file-like object that has a <tt class="methodname">write</tt> method),
    you can supply the stream as the optional
    <i class="parameter"><tt>outputStream</tt></i> argument to the Processor's
    <tt class="methodname">run</tt> method. When you supply your own output
    stream, the <tt class="methodname">run</tt> method will return
    <tt class="literal">None</tt>. Here is an example that writes directly to
    <tt class="constant">stdout</tt>:</p>
            <div class="$" id="ex.stdout"><a name="id3057740460L"></a>
              <div class="programlisting">
                <pre>SRC = """&lt;?xml version="1.0"?&gt;&lt;dummy/&gt;"""

STY = """&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="us-ascii"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;result&gt;hello world&lt;/result&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

import sys
from Ft.Xml import InputSource
from Ft.Xml.Xslt import Processor

src_isrc = InputSource.DefaultFactory.fromString(SRC, 'http://foo/dummy.xml')
sty_isrc = InputSource.DefaultFactory.fromString(STY, 'http://foo/dummy.xsl')

proc = Processor.Processor()
proc.appendStylesheet(sty_isrc)
result = proc.run(src_isrc, outputStream=sys.stdout)</pre>
              </div>
              <p class="caption"><b>Example&nbsp;1 &mdash; Transform output sent to standard out</b></p>
            </div>
            <p>You also have the option of other kinds of output. Just set the
    <tt class="literal">writer</tt> argument of the processor's
    <tt class="methodname">run</tt> method to an instance of an XSLT output
    writer, which is a handler of SAX-like events coming from the processor as
    it generates the result tree. 4Suite provides several writer classes for
    alternative output:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>If you want the XSLT output as SAX events, use an instance of
        <tt class="classname">Ft.Xml.Xslt.SaxWriter.SaxWriter</tt>. Give its
        constructor a <i class="parameter"><tt>saxHandler</tt></i> keyword argument that
        is your own PyXML SAX2 event handler.</p>
              </li>
              <li>
                <p>If you want the XSLT output as a Domlette document, use an
        instance of <tt class="classname">Ft.Xml.Xslt.RtfWriter.RtfWriter</tt>.
        Give its constructor a second argument: the base URI of the document
        to create. Obtain the document by calling the writer's
        <tt class="methodname">getResult</tt> method after XSLT processing is
        finished.</p>
              </li>
              <li>
                <p>If you want the XSLT output as any other kind of Python DOM
        document, use an instance of
        <tt class="classname">Ft.Xml.Xslt.DomWriter.DomWriter</tt>. Give its
        constructor an <i class="parameter"><tt>implementation</tt></i> keyword argument
        that is your desired DOM implementation. Also try to set the
        <i class="parameter"><tt>ownerDoc</tt></i> to an existing Document node (from the
        same implementation) from which a base URI for the new document can be
        obtained.</p>
              </li>
              <li>
                <p>If you want the XSLT output in a regular file, open a file for
        writing then pass this file object to the
        <tt class="function">proc.run</tt> as the
        <i class="parameter"><tt>outputStream</tt></i> parameter value, in the same way
        as the example above which used the <tt class="constant">sys.stdout</tt>
        file object. An example is shown below.</p>
              </li>
              <li>
                <p>If you want to make a custom output writer, just make your class
        extend <tt class="classname">Ft.Xml.Xslt.NullWriter.NullWriter</tt>. If it
        needs access to the XSLT output parameters, then the constructor
        should take an instance of
        <tt class="classname">Ft.Xml.Xslt.OutputParameters.OutputParameters</tt>,
        which will have the data attributes method, version, encoding,
        omitXmlDeclaration, standalone, doctypeSystem, doctypePublic,
        mediaType, cdataSectionElements, and indent, which your writer can act
        upon, if appropriate. See the <tt class="literal">NullWriter</tt> API
        documentation for further info.</p>
              </li>
            </ul>
            <p>Here is an example of writing to a regular Domlette document:</p>
            <div class="programlisting">
              <pre>SRC = """&lt;?xml version="1.0"?&gt;&lt;dummy/&gt;"""

STY = """&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="us-ascii"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;result&gt;hello world&lt;/result&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

import sys
from Ft.Xml import InputSource
from Ft.Xml.Xslt import Processor
from Ft.Xml.Xslt.DomWriter import DomWriter
from Ft.Xml.Domlette import PrettyPrint

src_isrc = InputSource.DefaultFactory.fromString(SRC, 'http://foo/dummy.xml')
sty_isrc = InputSource.DefaultFactory.fromString(STY, 'http://foo/dummy.xsl')

from Ft.Xml.Domlette import implementation as impl
domlette_writer = DomWriter(implementation=impl)

proc = Processor.Processor()
proc.appendStylesheet(sty_isrc)
proc.run(src_isrc, writer=domlette_writer)

result_doc = domlette_writer.getResult()
PrettyPrint(result_doc)</pre>
            </div>
            <p>This example writes the transform output to a file. This is a
    variant of <a href="#ex.stdout" title="Transform output sent to standard out">the earlier one</a>. Output is
    written to <tt class="filename">tmp.xml</tt>.</p>
            <div class="programlisting">
              <pre>SRC = """&lt;?xml version="1.0"?&gt;&lt;dummy/&gt;"""

STY = """&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:output method="xml" indent="yes" encoding="us-ascii"/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;result&gt;hello world&lt;/result&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

import sys
from Ft.Xml import InputSource
from Ft.Xml.Xslt import Processor

src_isrc = InputSource.DefaultFactory.fromString(SRC, 'http://foo/dummy.xml')
sty_isrc = InputSource.DefaultFactory.fromString(STY, 'http://foo/dummy.xsl')

proc = Processor.Processor()
proc.appendStylesheet(sty_isrc)

f = open('tmp.xml', mode='w')
result = proc.run(src_isrc, outputStream=f)
f.close()</pre>
            </div>
            <p>There are many more options available for customizing XSLT
    development; see the <tt class="classname">Processor</tt> module documentation
    for details:</p>
            <div class="screen">
              <pre>&gt;&gt;&gt; from Ft.Xml.Xslt import Processor
&gt;&gt;&gt; help(Processor)</pre>
            </div>
          </div>
          <div class="section"><a id="id3057751212L" name="id3057751212L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.8 </span>Transform chaining</h2>
            </div>
            <p>4Suite provides some hooks for scenarios where the output from one
    transform becomes the source document for another. This is called
    transform chaining. The user still has to write the sequence of transform
    invocations in the Python API (the 4xslt command can perform chaining for
    the user). This section shows how.</p>
            <p>In the following example the next transform in the chain is set from
    within XSLT.</p>
            <div class="programlisting">
              <pre># The first transform: just reproduces all para elements within a wrapper
TRANSFORM = """
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:f="http://xmlns.4suite.org/ext"
  extension-element-prefixes="f"
&gt;

&lt;!-- Top level param so that user can pass in the next transform in the
     chain.  By default, use the identity transform --&gt;
&lt;xsl:param name="next-xslt"/&gt;

&lt;!-- grab just the first paras for the output --&gt;
&lt;xsl:template match="/"&gt;
  &lt;parawrapper&gt;
    &lt;xsl:apply-templates select="//para"/&gt;
  &lt;/parawrapper&gt;
  &lt;!-- Set the next transform in the chain.  You can also set to a
       hard-coded string --&gt;
  &lt;!-- notice that this is within a template, for instantiation --&gt;
  &lt;f:chain-to href="{$next-xslt}"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;xsl:copy-of select="."/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;"""

DOC = """&lt;doc&gt;a&lt;para&gt;1&lt;/para&gt;b&lt;para&gt;2&lt;/para&gt;c&lt;/doc&gt;"""

from Ft.Xml.Xslt import Processor
from Ft.Xml import InputSource

transform = InputSource.DefaultFactory.fromString(TRANSFORM, "urn:x-bogus:main.xslt")

IDT = u'http://cvs.4suite.org/viewcvs/*checkout*/4Suite/Ft/Data/identity.xslt'

processor = Processor.Processor()
processor.appendStylesheet(transform)
source = InputSource.DefaultFactory.fromString(DOC, "urn:x-bogus:doc.xml")
result = processor.run(source, topLevelParams={(None, 'next-xslt'): IDT})
print result

# processor.chainTo is the fully-resolved absolute URI of the next transform,
# or None if there was no f:chain-to element instantiated in the transform that
# the processor last processed.
next = processor.chainTo

processor = Processor.Processor()
processor.appendStylesheet(InputSource.DefaultFactory.fromUri(next))
source = InputSource.DefaultFactory.fromString(DOC, "urn:x-bogus:doc.xml")
result = processor.run(source)
print result

next = processor.chainTo                      # Should now be None
print "chainTo:", processor.chainTo</pre>
            </div>
            <p>Note: There is not yet an API for automating the transform chain
    loop above. Ideas were discussed and an experiment was conducted <a href="http://mail.python.org/pipermail/xml-sig/2004-February/010146.html">here</a>.
    If you have ideas for a good API, please submit them to the mailing
    list.</p>
          </div>
          <div class="section"><a id="id3057751660L" name="id3057751660L"></a>
            <div>
              <h2 class="title"><span class="section-number">6.9 </span>XSLT patterns</h2>
            </div>
            <p>XSLT defines a pattern language based on XPath which is used to
    declare rules for matching patterns in the XML source against which to
    fire XSLT templates. The pattern implementation that 4Suite's XSLT library
    uses is also exposed as a library of its own. XSLT patterns are useful
    when your task is not so much to compute arbitrary information from a
    given node but, rather, to choose quickly from a collection of nodes the
    ones that meet some basic rules. This might seem a subtle difference. The
    following example might help illustrate it.</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>XPath task: extract the class attribute from all the child
        elements of the context node</p>
              </li>
              <li>
                <p>XSLT pattern task: given a list of nodes, sort them into piles
        of those that have a class attribute and those that have a title
        child</p>
              </li>
            </ul>
            <p>The main API for pattern processing in 4Suite is
    <tt class="classname">Ft.Xml.Xslt.PatternList</tt>. The following is a code
    snippet that takes a node and returns a list of patterns it
    matches.</p>
            <div class="programlisting">
              <pre>from <tt class="systemitem">Ft.Xml.Xslt</tt> import <tt class="classname">PatternList</tt>
from <tt class="systemitem">Ft.Xml.Domlette</tt> import <tt class="classname">NonvalidatingReader</tt>

# first pattern matches nodes with an href attribute
# the second matches elements with a title child
PATTERNS = ["*[@class]", "*[title]"]

# Second parameter is a dictionary of prefix to namespace mappings
plist = PatternList(PATTERNS, {})

DOC = """
&lt;spam&gt;
  &lt;e1 class="1"/&gt;
  &lt;e2&gt;&lt;title&gt;A&lt;/title&gt;&lt;/e2&gt;
  &lt;e3 class="2"&gt;&lt;title&gt;B&lt;/title&gt;&lt;/e3&gt;
&lt;/spam&gt;"""

doc = NonvalidatingReader.parseString(DOC, "file:foo.xml")
for node in doc.documentElement.childNodes:
    # Don't forget that the white space text nodes before and after
    # e1, e2 and e3 elements are also child nodes of the spam element
    if node.nodeName[0] == "e":
        print plist.lookup(node)</pre>
            </div>
            <p>The <tt class="classname">PatternList</tt> initializer takes my list of
    strings, which it conveniently converts to a list of compiled pattern
    objects. Such objects have a <tt class="methodname">match</tt> method that
    returns a boolean value, but I don't use these methods directly in this
    example. The <tt class="classname">PatternList</tt> initializer also takes a
    dictionary that makes up the namespace mapping. In this example, we use no
    namespaces, so the dictionary is empty. The
    <tt class="methodname">lookup</tt> method is applied to a selection of the
    children of the <tt class="sgmltag">spam</tt> element (all the
    nodes whose name starts with "e", which happens to be all the element
    nodes). The output of listing 4 follows:</p>
            <div class="screen">
              <pre>[*[attribute::class]]
[*[child::title]]
[*[attribute::class], *[child::title]]</pre>
            </div>
            <p>The output is a list of the representations of the pattern objects
    that matched each node. Notice how the axis abbreviations have been
    expanded in the pattern object representation.</p>
          </div>
        </div>
        <div class="section"><a id="id3057724588L" name="id3057724588L"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">7 </span>XPath and XSLT extensions</h1>
          </div>
          <p>Sometimes the built-in facilities of XPath and XSLT aren't quite
  enough to meet your processing needs. Luckily it's easy to extend the
  function of these libraries using user extension functions and elements,
  which are written in Python.</p>
          <div class="section"><a id="id3057725100L" name="id3057725100L"></a>
            <div>
              <h2 class="title"><span class="section-number">7.1 </span>Extension functions (XPath and XSLT)</h2>
            </div>
            <p>To define your own extension functions for XPath and XSLT, you write
    corresponding Python function in a module, and provide a mapping from the
    desired XPath function names to Python function objects (or any callables).  Start with a simple example.  The following is a complete module which defines a single XPath function, <tt class="methodname">unichr(s)</tt>  a simple example that takes a string and returns the Unicode code point number for the first character in that string.</p>
            <div class="programlisting">
              <pre>#ord.py
from Ft.Xml.XPath import Conversions

def Ord(context, s):
    '''
    Available in XPath as ord() as defined by ExtFunctions mapping below
    Takes an object, which is coerced to string
    Returns the Unicode code point number for the first character in that string    Or returns -1 if it's an empty string
    '''
    s = Conversions.StringValue(s)  #Coerce the passed object to string
    if s:
        return ord(s[0])
    else:
        return -1

ExtFunctions = {
    (u'urn:x-4suite:x', u'ord'): Ord,
}

</pre>
            </div>
            <p>As this simple example illustrates, The
    basic way to map XPath function names to Python function objects is in
    dictionary named "ExtFunctions", global to the module in which the
    extension function is defined.   The XPath/XSLT extension names are
    expressed as a Python tuple of two Unicode objects.  If you're familiar
    with XPath, this is just a Python representation of an expanded name.
    The first item in the expanded name tuple is
    the namespace URI for the element, and the second is the local name.
    The namespace URI cannot be an empty string.</p>
            <p>You have to actually tell the processor to load your extension modules.  There are several ways to do so.</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>From Python code you can register them in a context object used for XPath processing
        by using the optional
        <i class="parameter"><tt>extModuleList</tt></i> to pass in a list of module
        objects.</p>
              </li>
              <li>
                <p>You can also register particular functions rather than a
complete module in a XPath context object using the
        optional <i class="parameter"><tt>extFunctionMap</tt></i> argument.  It takes
        a mapping dictionary similar to the <tt class="constant">ExtFunctions</tt> dictionary shown in the above sample module.</p>
              </li>
              <li>
                <p>If you are using the XSLT processor you can register extension functions on a processor object using
        the <tt class="methodname">registerExtensionModules()</tt> method.</p>
              </li>
              <li>
                <p>When using the XSLT processor you can also register individual extension functions on a processor object using
        <tt class="methodname">registerExtentionFunction()</tt> method.  It takes
        the namespace and
        localName for the extension function and the callable object that implements it).</p>
              </li>
              <li>
                <p>In some cases the user can list extension modules using
        the environment variable "EXTMODULES". "EXTMODULES" is a
        colon-separated list of Python modules names. This works for the 4xslt
        command line and for <tt class="classname">Ft.Xml.XPath.Evaluate</tt>. For
        other APIs, use one of the other two methods, which can easily be
        extended to read the "EXTMODULES" variable.  In general the other methods for registering extensions are preferable.</p>
              </li>
            </ol>
            <p>Note that extension modules will automatically be
    searched for XSLT extension elements as well as functions.</p>
            <p>The following is a longer example, a module that implements two functions are. One returns
    the current time and the other creates a hash of the context node name:</p>
            <div class="programlisting">
              <pre># demo.py
import time, urlparse
from Ft.Xml.XPath import Conversions

def GetCurrentTime(context):
    '''available in XPath as get-current-time()'''
    return time.asctime(time.localtime())

def HashContextName(context, maxkey):
    '''
    available in XPath as hash-context-name(maxkey),
    where maxkey is an object converted to number
    '''
    # It is a good idea to use the appropriate core function to coerce
    # arguments to the expected type
    maxkey = Conversions.NumberValue(maxkey)
    key = reduce(lambda a, b: a + b, context.node.nodeName)
    return key % maxkey

ExtFunctions = {
    ('urn:x-4suite:x', 'get-current-time'): GetCurrentTime,
    ('urn:x-4suite:x', 'hash-context-name'): HashContextName
}

</pre>
            </div>
            <p>You can use this in plain XPath as follows:</p>
            <div class="programlisting">
              <pre>from <tt class="systemitem">Ft.Xml.XPath.Context</tt> import <tt class="classname">Context</tt>
from <tt class="systemitem">Ft.Xml.XPath</tt> import <tt class="classname">Compile</tt>, <tt class="classname">Evaluate</tt>
from <tt class="systemitem">Ft.Xml.Domlette</tt> import <tt class="classname">NonvalidatingReader</tt>

DOC = "&lt;spam xmlns='http://spam.com'&gt;eggs&lt;/spam&gt;"

ctx = Context(None, extFunctionMap=demo.ExtFunctions,
              processorNss={"a": "http://spam.com"})
expr = Compile("get-current-time()")

doc = NonvalidatingReader.parseString(DOC, "http://spam.com/base")
print Evaluate(expr, doc, ctx)</pre>
            </div>
            <p>Notice that you might choose to use None for the extension function
    namespaces. If so, you don't need to specify the processorNss context
    attribute, but you might want to watch out for clashes with other
    extenstion function names, including the built-in library. Again, if you
    plan to use an extension function from within XSLT, its namespace URI must
    not be None.</p>
            <p>You can use this in XSLT just as easily:</p>
            <div class="programlisting">
              <pre># useextfunc.py

TRANSFORM = """&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:s="urn:x-4suite:x"
  version="1.0"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:value-of select="s:get-current-time()"/&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
"""

SOURCE = """&lt;dummy/&gt;"""

from <tt class="systemitem">Ft.Xml.Xslt</tt> import <tt class="classname">Processor</tt>
processor = Processor.Processor()

# Register the extension function using method (3)
processor.registerExtensionModules(['demo'])
from Ft.Xml import InputSource
transform = InputSource.DefaultFactory.fromString(TRANSFORM, "http://foo.com")
source = InputSource.DefaultFactory.fromString(SOURCE, "http://foo.com")
processor.appendStylesheet(transform)
result = processor.run(source)
print result</pre>
            </div>
            <p>For good examples of modules with extension elements, see the source code for the modules
    <tt class="classname">Ft.Xml.XPath.BuiltInExtFunctions</tt>,
    <tt class="classname">Ft.Xml.Xslt.BuiltInExtFunctions</tt> and the modules in
    <tt class="systemitem">Ft.Xml.Xslt.Exslt</tt>. The latter are
    especially good examples given their diversity and detailed specifications
    at <a href="http://exslt.org">exslt.org</a>.</p>
          </div>
          <div class="section"><a id="id3057768684L" name="id3057768684L"></a>
            <div>
              <h2 class="title"><span class="section-number">7.2 </span>Extension elements (XSLT)</h2>
            </div>
            <p>To define your own extension elements, define a class derived from
    <tt class="classname">Ft.Xml.Xslt.XsltElement</tt>. The module in which it is
    defined should have a global dictionary named "ExtElements" mapping element
    expanded names to element class objects.</p>
            <p>Finally, modules containing any extension elements used must be
    indicated as such to the processor in one of several ways.</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>You can register all extension functions and elements in a module by using a processor object's
        <tt class="methodname">registerExtensionModules()</tt> method.</p>
              </li>
              <li>
                <p>You can also register individual extension elements on a processor object using
        <tt class="methodname">registerExtensionElement()</tt> method.  It takes
        the namespace and
        localName for the extension function and the callable object that implements it).</p>
              </li>
              <li>
                <p>In some cases the user can list extension modules using
        the environment variable "EXTMODULES". "EXTMODULES" is a
        colon-separated list of Python modules names. This works for the 4xslt
        command line and for <tt class="classname">Ft.Xml.XPath.Evaluate</tt>. For
        other APIs, use one of the other two methods, which can easily be
        extended to read the "EXTMODULES" variable.  In general the other methods for registering extensions are preferable.</p>
              </li>
            </ol>
            <p>Note that extension modules will automatically be
    searched for XPath extension functions as well as Extension
    elements.</p>
          </div>
          <div class="section"><a id="id3057769772L" name="id3057769772L"></a>
            <div>
              <h2 class="title"><span class="section-number">7.3 </span>Extension element API</h2>
            </div>
            <p>There are several aspects of the extension element API worth
    discussing in more detail.</p>
            <p>The class-level "content" variable specifies a content model to be
    enforced by the XSLT processor. If the element is used in a way that
    doesn't meet the specified content model, the user will get an error
    message. The content model is a structure that uses certain special
    classes, including:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>ContentInfo.Empty - matches no content at all (empty
        element)</p>
              </li>
              <li>
                <p>ContentInfo.Text - matches plain text content</p>
              </li>
              <li>
                <p>ContentInfo.Seq - matches the given sequence of
        sub-patterns</p>
              </li>
              <li>
                <p>ContentInfo.Alt - matches one of the given choice of
        sub-patterns</p>
              </li>
              <li>
                <p>ContentInfo.Rep - matches 0 or more repeated instances of the
        given sub-pattern</p>
              </li>
              <li>
                <p>ContentInfo.Rep1 - matches 0 or more repeated instances of the
        given sub-pattern</p>
              </li>
              <li>
                <p>ContentInfo.Opt - matches zero or one of the given
        sub-pattern</p>
              </li>
              <li>
                <p>ContentInfo.ResultElements - matches elements not in the XSL
        namespace</p>
              </li>
              <li>
                <p>ContentInfo.Instructions - matches any sequence of XSLT elements
        categorized as instructions in the spec</p>
              </li>
              <li>
                <p>ContentInfo.Template - matches an XSLT template body according
        to the spec</p>
              </li>
              <li>
                <p>ContentInfo.TopLevelElements - matches any sequence of XSLT
        elements categorized as top level in the spec</p>
              </li>
              <li>
                <p>ContentInfo.QName - matches a particular element by giving its
        namespace and node name (the prefix in the node name is only used for
        documentation and error messages)</p>
              </li>
            </ul>
            <p>So, for instance, the xsl:choose element would be described
    as</p>
            <div class="programlisting">
              <pre>content = ContentInfo.Seq(
    ContentInfo.Rep1(ContentInfo.QName(XSL_NAMESPACE, 'xsl:when')),
    ContentInfo.Opt(ContentInfo.QName(XSL_NAMESPACE, 'xsl:otherwise')),
    )</pre>
            </div>
            <p>The class-level "legalAttrs" variable specifies the attributes
    allowed or required on the element. It is a Python dictionary mapping
    attribute name to its specification. The specification is a class
    according o the type of attribute.</p>
            <p>The following are the supported attribute classes. The parameters
    specified are for the initializer. Note that most general patterns have a
    plain variant and an attribute value template (AVT) variant:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>AttributeInfo.String - any XPath string</p>
              </li>
              <li>
                <p>AttributeInfo.StringAvt - an AVT yielding any string</p>
              </li>
              <li>
                <p>AttributeInfo.Char - any XPath string of length 1</p>
              </li>
              <li>
                <p>AttributeInfo.CharAvt - AVT version of Char</p>
              </li>
              <li>
                <p>AttributeInfo.Choice - a string which must be one of a number of
        given values. The values are given by a list of strings with is the
        first parameter</p>
              </li>
              <li>
                <p>AttributeInfo.ChoiceAvt - AVT version of Choice</p>
              </li>
              <li>
                <p>AttributeInfo.YesNo - Abbreviation for AttributeInfo.Choice (
        See <a href="http://www.oasis-open.org/committees/relax-ng/tutorial-20011203.html">Oasis
        web site</a>)</p>
              </li>
              <li>
                <p>AttributeInfo.YesNoAvt - AVT version of YesNo</p>
              </li>
              <li>
                <p>AttributeInfo.Number - any XPath number</p>
              </li>
              <li>
                <p>AttributeInfo.NumberAvt - AVT version of Number</p>
              </li>
              <li>
                <p>AttributeInfo.UriReference - XPath string that is syntactically
        a URI reference</p>
              </li>
              <li>
                <p>AttributeInfo.UriReferenceAvt - AVT version of
        UriReference</p>
              </li>
              <li>
                <p>AttributeInfo.Id - XPath string that is syntactically an XML
        ID</p>
              </li>
              <li>
                <p>AttributeInfo.IdAvt - AVT version of Id</p>
              </li>
              <li>
                <p>AttributeInfo.QName - XPath string that is syntactically an XML
        namespaces qualified name</p>
              </li>
              <li>
                <p>AttributeInfo.QNameAvt - AVT version of QName</p>
              </li>
              <li>
                <p>AttributeInfo.NCName - XPath string that is syntactically an XML
        namespaces "no colon" name</p>
              </li>
              <li>
                <p>AttributeInfo.NCNameAvt - AVT version of NCName</p>
              </li>
              <li>
                <p>AttributeInfo.Prefix - Same as NCName</p>
              </li>
              <li>
                <p>AttributeInfo.PrefixAvt - Same as NCNameAvt</p>
              </li>
              <li>
                <p>AttributeInfo.NMToken - XPath string that is syntactically an
        XML Name token</p>
              </li>
              <li>
                <p>AttributeInfo.NMTokenAvt - AVT version of NMToken</p>
              </li>
              <li>
                <p>AttributeInfo.QNameButNotNCName - A QName that contains a
        colon</p>
              </li>
              <li>
                <p>AttributeInfo.QNameButNotNCNameAvt - AVT version of
        QNameButNotNCName</p>
              </li>
              <li>
                <p>AttributeInfo.Token - XPath string that is syntactically an
        XPath name test (i.e. "foo", "ns:foo", ns:<strong class="emphasis">" or
        "</strong>")</p>
              </li>
              <li>
                <p>AttributeInfo.TokenAvt - AVT version of Token</p>
              </li>
              <li>
                <p>AttributeInfo.Expression - XPath string that is syntactically an
        XPath expression</p>
              </li>
              <li>
                <p>AttributeInfo.ExpressionAvt - AVT version of Expression</p>
              </li>
              <li>
                <p>AttributeInfo.StringExpression - XPath string that is
        syntactically an XPath expression, which would be expected to return a
        string value</p>
              </li>
              <li>
                <p>AttributeInfo.StringExpressionAvt - AVT version of
        StringExpression</p>
              </li>
              <li>
                <p>AttributeInfo.NodeSetExpression - XPath string that is
        syntactically an XPath expression, which would be expected to return a
        node set value</p>
              </li>
              <li>
                <p>AttributeInfo.NodeSetExpressionAvt - AVT version of
        NodeSetExpression</p>
              </li>
              <li>
                <p>AttributeInfo.NumberExpression - XPath string that is
        syntactically an XPath expression, which would be expected to return a
        number value</p>
              </li>
              <li>
                <p>AttributeInfo.NumberExpressionAvt - AVT version of
        NumberExpression</p>
              </li>
              <li>
                <p>AttributeInfo.BooleanExpression - XPath string that is
        syntactically an XPath expression, which would be expected to return a
        boolean value</p>
              </li>
              <li>
                <p>AttributeInfo.BooleanExpressionAvt - AVT version of
        BooleanExpression</p>
              </li>
              <li>
                <p>AttributeInfo.Pattern - XPath string that is syntactically an
        XSLY pattern</p>
              </li>
              <li>
                <p>AttributeInfo.PatternAvt - AVT version of Pattern</p>
              </li>
              <li>
                <p>AttributeInfo.Tokens - XPath string that is syntactically a
        space-delimited series of tokens</p>
              </li>
              <li>
                <p>AttributeInfo.TokensAvt - AVT version of Tokens</p>
              </li>
              <li>
                <p>AttributeInfo.QNames - XPath string that is syntactically a
        space-delimited series of QNames</p>
              </li>
              <li>
                <p>AttributeInfo.QNamesAvt - AVT version of QNames</p>
              </li>
              <li>
                <p>AttributeInfo.Prefixes - XPath string that is syntactically a
        space-delimited series of NCNames</p>
              </li>
              <li>
                <p>AttributeInfo.PrefixesAvt - AVT version of Prefixes</p>
              </li>
            </ul>
            <p>All of these classes take the following optional keyword
    parameters:</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>description - for documentation</p>
              </li>
              <li>
                <p>default - the default value of the attribute to be used if
        omitted</p>
              </li>
            </ul>
            <p>Some examples from the XSLT spec:</p>
            <p>xsl:output</p>
            <div class="programlisting">
              <pre>content = ContentInfo.Empty
legalAttrs = {
    'method' : AttributeInfo.QName(),
    'version' : AttributeInfo.NMToken(),
    'encoding' : AttributeInfo.String(),
    'omit-xml-declaration' : AttributeInfo.YesNo(),
    'standalone' : AttributeInfo.YesNo(),
    'doctype-public' : AttributeInfo.String(),
    'doctype-system' : AttributeInfo.String(),
    'cdata-section-elements' : AttributeInfo.QNames(),
    'indent' : AttributeInfo.YesNo(),
    'media-type' : AttributeInfo.String(),
    }</pre>
            </div>
            <p>xsl:sort</p>
            <div class="programlisting">
              <pre>content = ContentInfo.Empty
legalAttrs = {
    'select' : AttributeInfo.StringExpression(default='.'),
    'lang' : AttributeInfo.NMTokenAvt(),
    # We don't support any additional data-types, hence no
    # AttributeInfo.QNameButNotNCName()
    'data-type' : AttributeInfo.ChoiceAvt(['text', 'number'],
                                          default='text'),
    'order' : AttributeInfo.ChoiceAvt(['ascending', 'descending'],
                                      default='ascending'),
    'case-order' : AttributeInfo.ChoiceAvt(['upper-first', 'lower-first']),
    }</pre>
            </div>
            <p>xsl:number</p>
            <div class="programlisting">
              <pre>content = ContentInfo.Empty
legalAttrs = {
    'level' : AttributeInfo.Choice(['single', 'multiple', 'any'],
                                   default='single'),
    'count' : AttributeInfo.Pattern(),
    'from' : AttributeInfo.Pattern(),
    'value' : AttributeInfo.Expression(),
    'format' : AttributeInfo.StringAvt(default='1'),
    'lang' : AttributeInfo.NMToken(),
    'letter-value' : AttributeInfo.ChoiceAvt(['alphabetic', 'traditional']),
    'grouping-separator' : AttributeInfo.CharAvt(),
    'grouping-size' : AttributeInfo.NumberAvt(default=0),
    }</pre>
            </div>
            <p>Of course, it's always a good idea to use descriptions, which the
    above do not.</p>
            <p>For good examples of modules with extension elements, see the source code for the modules
    Ft.Xml.Xslt.BuiltInExtElements and Ft.Xml.Xslt.Exslt.Common . The various
    modules in Ft.Xml.Xslt.Exslt have a strong diversity and make good
    examples, especially given their detailed specifications at <a href="http://exslt.org">exslt.org</a></p>
            <div class="section"><a id="id3057279212L" name="id3057279212L"></a>
              <div>
                <h3 class="title"><span class="section-number">7.3.1 </span>Controlling output from XSLT extensions</h3>
              </div>
              <p>The most common special need for XSLT extensions is to generate
      XSLT output. For extension elements this is easy enough to do using the
      API on the procssor instance that is passed to the instantiate() method
      of extension element classes. For example</p>
              <div class="programlisting">
                <pre>class SpamElement(XsltElement):
    legalAttrs = {}
    def instantiate(self, context, processor):
        processor.output().startElement('title')
        processor.output().text('Life of Brian'))
        processor.output().endElement('title')
        return (context,)</pre>
              </div>
              <p>Extension functions are not passed a processor instance directly,
      but context objects hold a reference to the processor in effect, so the
      following example works:</p>
              <div class="programlisting">
                <pre>def Spam(context):
    context.processor.output().startElement('title')
    context.processor.output().text('Life of Brian'))
    context.processor.output().endElement('title')
    return</pre>
              </div>
              <p>However, it is probably better design to reserve such side effects
      as output for extension elements rather than functions.</p>
              <p>In the above examples the elements and text out out just use the
      current output parameters. In order to change output parameters or
      change the output stream, you can stack a new output handler:</p>
              <div class="programlisting">
                <pre>stream = cStringIO.StringIO()

# Clone the current outputparameters
op = processor.writers[-1]._outputParams.clone()

# Force XML output method with XML declaration
# Output method is a qualified name, so must flag null ns
# to use standard xml method
op.method = (EMPTY_NAMESPACE, 'xml')
op.omitXmlDeclaration = "yes"

# Push the new handler to the top of the writer stack
processor.addHandler(op, stream)
processor.output().startElement('title')
processor.output().text('Life of Brian'))
processor.output().endElement('title')

# Pop back to the previous handler stream.getvalue()
# now contains the new  output
processor.removeHandler()</pre>
              </div>
            </div>
            <div class="section"><a id="id3057279788L" name="id3057279788L"></a>
              <div>
                <h3 class="title"><span class="section-number">7.3.2 </span>Creating result tree fragments</h3>
              </div>
              <p>Another common need is to treat the body of an extension element
      as a template so that something can be done with the RTF that results
      from it. The following example demonstrates this:</p>
              <div class="programlisting">
                <pre>try:
    # Set the output to an RTF riter, which wll create an RTF for us
    processor.pushResultTree(self.baseUri)

    # The template is manifested as children of the extension element
    # node.  Instantiate each in turn
    for child in self.children:
        child.instantiate(context, processor)
# You want to be sure you re-balance the stack even in case of error
finally:
    # Retrieve the resulting RTF
    result_rtf = processor.popResult()</pre>
              </div>
            </div>
            <div class="section"><a id="id3057280044L" name="id3057280044L"></a>
              <div>
                <h3 class="title"><span class="section-number">7.3.3 </span>Comunicating with the external code that invokes XSLT</h3>
              </div>
              <p>You can set and communicate state information with external code
      by using the processor.extensionParams attribute. For example, the
      following sents a time stamp of precisely when the extension was
      instantiated, which can later be retrieved from the processor after the
      XSLT process, or even by later extensions. In a similar way, state can
      be set up by calling functions and retrieved by extensions.</p>
              <div class="programlisting">
                <pre># Extension parameters have fully qualified names, so you must come up
# with a namespace to set them
processor.extensionParams[(SPAM_NAMESPACE, 'tstamp')] = time.time()</pre>
              </div>
            </div>
          </div>
        </div>
        <div class="section" id="mwriter"><a id="mwriter" name="mwriter"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">8 </span>Streaming XML output</h1>
          </div>
          <p><tt class="classname">MarkupWriter</tt> is a streaming
  <span class="acronym">API</span> for generating <span class="acronym">XML</span>. The
  <tt class="literal">Ft.Xml.MarkupWriter</tt> class is specialized for creating
  <span class="acronym">XML</span> documents from scratch. Documents written with
  <tt class="classname">MarkupWriter</tt> are written to the output (standard
  output or another file-like object) as you build them, so if you need to
  process the document in memory, you may need another tool such as a DOM-like
  tool (e.g. Domlette, Amara, etc).</p>
          <p>4Suite partitions <span class="acronym">XML</span> serializers into two
  categories: writers and printers.
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>A writer is a module that exposes a broad public
        <span class="acronym">API</span> for building output incrementally.</p>
              </li>
              <li>
                <p>A printer is a module that simply takes a <span class="acronym">DOM</span>
        and creates output from it as a whole, within one
        <span class="acronym">API</span> invocation.</p>
              </li>
            </ul><tt class="classname">MarkupWriter</tt> is the primary example
  of this writer category of <span class="acronym">XML</span> serializers.</p>
          <p>The following example uses this class for generating a simple
  <span class="acronym">XML</span> Software Autoupdate (XSA) file. XSA is a
  <span class="acronym">XML</span> data format for listing and describing software
  packages.</p>
          <div class="programlisting">
            <pre>from <tt class="systemitem">Ft.Xml</tt> import <tt class="classname">MarkupWriter</tt>

# Set the output doc type details (required by XSA)
SYSID = u"http://www.garshol.priv.no/download/xsa/xsa.dtd"
PUBID = u"-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML"
writer = MarkupWriter(indent=u"yes", doctypeSystem=SYSID,
                      doctypePublic=PUBID)
writer.startDocument()
writer.startElement(u'xsa')
writer.startElement(u'vendor')

# Element with simple text (#PCDATA) content
writer.simpleElement(u'name', content=u'Centigrade systems')
writer.simpleElement(u'email', content=u"info@centigrade.bogus")
writer.endElement(u'vendor')

# Element with an attribute
writer.startElement(u'product', attributes={u'id': u"100\u00B0"})
writer.simpleElement(u'name', content=u"100\u00B0 Server")
writer.simpleElement(u'version', content=u"1.0")
writer.simpleElement(u'last-release')
writer.text(u"20030401")

# Empty element
writer.simpleElement(u'changes')
writer.endElement(u'product')
writer.endElement(u'xsa')
writer.endDocument()</pre>
          </div>
          <p>This is the output we get from the code above: 
            <div class="screen">
              <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE xsa PUBLIC "-//LM Garshol//DTD XML Software Autoupdate 1.0//EN//XML" "http://www.garshol.priv.no/download/xsa/xsa.dtd"&gt;
&lt;xsa&gt;
  &lt;vendor&gt;
    &lt;name&gt;Centigrade systems&lt;/name&gt;
    &lt;email&gt;info@centigrade.bogus&lt;/email&gt;
  &lt;/vendor&gt;
  &lt;product id="100&deg;"&gt;
    &lt;name&gt;100&deg; Server&lt;/name&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;last-release&gt;20030401&lt;/last-release&gt;
    &lt;changes/&gt;
  &lt;/product&gt;
&lt;/xsa&gt;</pre>
            </div>
          </p>
          <p>The above example illustrates some of the basics of using the
  <tt class="classname">MarkupWriter</tt> class. The following sections describe
  both the essential and the advanced features of this class. In many cases,
  there often exists more than one way to output a given document
  section.</p>
          <div class="section" id="mwriter.begin"><a id="mwriter.begin" name="mwriter.begin"></a>
            <div>
              <h2 class="title"><span class="section-number">8.1 </span>Starting with MarkupWriter</h2>
            </div>
            <p>After importing the <tt class="classname">MarkupWriter</tt> class, you
    have to create a <tt class="classname">MarkupWriter</tt> object instance and
    then start the new Document. (See below for <a href="#mwriter.output" title="Setting up the output">output options</a> of
    <tt class="classname">MarkupWriter</tt>.) Remember that you are working with a
    streaming <span class="acronym">API</span>. You must decide what features you want
    your output to have before you start to write that output.
              <div class="programlisting">
                <pre>&gt;&gt;&gt; from Ft.Xml import MarkupWriter
&gt;&gt;&gt; writer = MarkupWriter()
&gt;&gt;&gt; writer.startDocument() </pre>
              </div>
            </p>
            <p>You are now ready to add data to the new document.</p>
            <div class="important"><span class="label">Important</span>
              <p>Make sure that all of your data (element names, attributes,
      content, etc) are Python unicode objects.</p>
            </div>
          </div>
          <div class="section" id="mwriter.elements"><a id="mwriter.elements" name="mwriter.elements"></a>
            <div>
              <h2 class="title"><span class="section-number">8.2 </span>How to insert elements</h2>
            </div>
            <p>There are two ways to add new elements as children of other document
    or element nodes.</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>When you want to add a new element that will itself have child
        elements, you can use the
        <tt class="methodname">startElement</tt>/<tt class="methodname">endElement</tt>
        method combination to signal the beginning and the ending of an
        element, respectively.
                  <div class="programlisting">
                    <pre>writer.startElement(u'xsa')
# other document content can be output here
writer.endElement(u'xsa')</pre>
                  </div>
                </p>
              </li>
              <li>
                <p>Alternatively, you can use the
        <tt class="methodname">simpleElement</tt> method, which is a shortcut for
        the
        <tt class="methodname">startElement</tt>/<tt class="methodname">endElement</tt>
        combination and produces an element with no content or with text
        content (if you specify the <i class="parameter"><tt>content</tt></i> parameter).
        
                  <div class="programlisting">
                    <pre>writer.simpleElement(u'xsa')</pre>
                  </div>
                </p>
              </li>
            </ol>
          </div>
          <div class="section" id="mwriter.attributes"><a id="mwriter.attributes" name="mwriter.attributes"></a>
            <div>
              <h2 class="title"><span class="section-number">8.3 </span>How to insert attributes</h2>
            </div>
            <p>There are two ways to add attributes to elements:</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>First, you can use the <i class="parameter"><tt>attributes</tt></i>
        parameter of the <tt class="methodname">startElement</tt> method. This
        parameter is a dictionary which maps each attribute name to the value
        of that attribute. If an attribute's name is in a namespace, then you
        must specify the name as a Python tuple, with the attribute's QName as
        the first member of the tuple, and the namespace URI as the second
        member of the tuple. For an example of this advanced syntax, see <a href="#mwriter.examples.xhtml" title="Writing XHTML with MarkupWriter">&ldquo;Writing XHTML with <tt class="classname">MarkupWriter</tt>&rdquo;</a>.
                  <div class="programlisting">
                    <pre>writer.startElement(u'product', attributes={u'id': u"100\u00B0"}</pre>
                  </div>
                </p>
              </li>
              <li>
                <p>Alternatively, you can use a distinct
        <tt class="methodname">attribute</tt> method with two parameters: the
        attribute's name and the attribute's value. As with the dictionary
        approach above, if the attribute's name is in a namespace, then the
        whole name should be a Python tuple. 
                  <div class="programlisting">
                    <pre>writer.startElement(u'product')
writer.attribute(u'id', u"100\u00B0")</pre>
                  </div>
                </p>
              </li>
            </ol>
          </div>
          <div class="section" id="mwriter.text"><a id="mwriter.text" name="mwriter.text"></a>
            <div>
              <h2 class="title"><span class="section-number">8.4 </span>How to insert text nodes</h2>
            </div>
            <p>Similarly, there are two ways to add text nodes to elements.</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>First, the <tt class="methodname">simpleElement</tt> method takes a
        <i class="parameter"><tt>content</tt></i> parameter, which can be used to create
        a single text node child of the node with the specified
        name.
                  <div class="programlisting">
                    <pre>writer.simpleElement(u'name', content=u'Centigrade systems')</pre>
                  </div>
                </p>
              </li>
              <li>
                <p>Alternatively, instances of the
        <tt class="classname">MarkupWriter</tt> class, such as
        <tt class="varname">writer</tt>, have a <tt class="methodname">text</tt> method
        that inserts a single text node as the <em class="emphasis">next</em> child
        of the element which was last started with the
        <tt class="methodname">startElement</tt> method and which has not yet
        been closed with the <tt class="methodname">endElement</tt>
        method.
                  <div class="programlisting">
                    <pre>writer.startElement(u'product')
writer.text(u'Centigrade systems')
writer.endElement(u'product')</pre>
                  </div>
                </p>
              </li>
            </ol>
          </div>
          <div class="section" id="mwriter.chunk"><a id="mwriter.chunk" name="mwriter.chunk"></a>
            <div>
              <h2 class="title"><span class="section-number">8.5 </span>How to insert a complete chunk</h2>
            </div>
            <p><tt class="classname">MarkupWriter</tt> also allows you to insert
    well-formed <span class="acronym">XML</span> entities as complete chunks in the
    output. This is a very convenient way to emit boilerplate
    <span class="acronym">XML</span> without breaking it down into all the separate
    element/attribute/content bits. As such the lines:</p>
            <div class="programlisting">
              <pre>writer.simpleElement(u'name', content=u"100\u00B0 Server")
writer.simpleElement(u'version', content=u"1.0")
writer.simpleElement(u'last-release', content=u"20030401")</pre>
            </div>
            <p>Could instead be written:</p>
            <div class="programlisting">
              <pre>writer.xmlFragment("""
&lt;name&gt;100&deg; Server&lt;/name&gt;
&lt;version&gt;1.0&lt;/version&gt;
&lt;last-release&gt;20030401&lt;/last-release&gt;""")</pre>
            </div>
            <div class="important"><span class="label">Important</span>
              <p>The parameter of <tt class="methodname">xmlFragment</tt> is a string,
      not a unicode object.</p>
            </div>
          </div>
          <div class="section" id="mwriter.pi"><a id="mwriter.pi" name="mwriter.pi"></a>
            <div>
              <h2 class="title"><span class="section-number">8.6 </span>How to insert processing instructions and comments</h2>
            </div>
            <p>The API provides the <tt class="methodname">comment</tt> and
    <tt class="methodname">processingInstruction</tt> methods for inserting
    processing instructions and comments. The <tt class="methodname">comment</tt>
    method takes a unicode string, which is the intended value of the comment.
    The <tt class="methodname">processingInstruction</tt> method takes two
    unicode strings. The first is the name of the processing instruction, and
    the second is the value of the processing instruction. For example, the
    following code:
              <div class="programlisting">
                <pre>writer.comment(u"This is a processing instruction")
writer.processingInstruction(u'xml-stylesheet', u'type="text/xsl" href="akara.xsl"')</pre>
              </div>produces
    the following output:
              <div class="screen">
                <pre>&lt;!--This is a processing instruction--&gt;
&lt;?xml-stylesheet type="text/xsl" href="akara.xsl"?&gt;</pre>
              </div>
            </p>
          </div>
          <div class="section" id="mwriter.ns"><a id="mwriter.ns" name="mwriter.ns"></a>
            <div>
              <h2 class="title"><span class="section-number">8.7 </span>Using namespaces</h2>
            </div>
            <p>When you create a new element or an attribute, you can use
    namespaces. See the next program:</p>
            <div class="programlisting">
              <pre>from <tt class="systemitem">Ft.Xml</tt> import <tt class="classname">MarkupWriter</tt>

writer = <tt class="classname">MarkupWriter</tt>(indent=u'yes')
writer.startDocument()

RDFNS = u"http://www.w3.org/1999/02/22-rdf-syntax-ns#"

writer.startElement(u"rdf:RDF", RDFNS)
writer.startElement(u"rdf:Description", RDFNS,
    attributes={(u'rdf:about', RDFNS): u'http://media.example.com/audio/guide.ra'})
writer.endElement(u'rdf:Description', RDFNS)
writer.endElement(u'rdf:RDF', RDFNS)</pre>
            </div>
            <p>And this is the output:</p>
            <div class="screen">
              <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
    &lt;rdf:Description rdf:about="http://media.example.com/audio/guide.ra"/&gt;
&lt;/rdf:RDF&gt;</pre>
            </div>
          </div>
          <div class="section" id="mwriter.output"><a id="mwriter.output" name="mwriter.output"></a>
            <div>
              <h2 class="title"><span class="section-number">8.8 </span>Setting up the output</h2>
            </div>
            <p>In the above example, you can see how parameters that control the
    output are passed into the <tt class="classname">MarkupWriter</tt>
    initializer, including document type info and whether to indent (pretty
    print).</p>
            <p>You can pass any of the usual controls for XSLT output into the
    initializer this way.</p>
            <div class="variablelist">
              <dl>
                <dt><i class="parameter"><tt>stream</tt></i></dt>
                <dd>
                  <p>By default <tt class="classname">MarkupWriter</tt> sends its
          output to <tt class="varname">sys.stdout</tt>, but you can substitute any
          file-like object by passing in an initializer parameter. This stream
          parameter should be the first argument to the
          <tt class="classname">MarkupWriter</tt> constructor. For example:
          
                    <div class="programlisting">
                      <pre>output_file = file('output.xml', 'w')
writer = MarkupWriter(output_file, indent=u"yes")</pre>
                    </div>
                  </p>
                </dd>
                <dt><i class="parameter"><tt>indent</tt></i></dt>
                <dd>
                  <p>The indent named parameter controls whether or not the output
          will have whitespace inserted to indent tags in the output. The
          default is "no".</p>
                </dd>
                <dt><i class="parameter"><tt>doctypeSystem</tt></i>,
        <i class="parameter"><tt>doctypePublic</tt></i></dt>
                <dd>
                  <p>These two named parameters control the system and public
          identifiers that will be included in the output.</p>
                </dd>
                <dt><i class="parameter"><tt>omitXmlDeclaration</tt></i>=u"yes"</dt>
                <dd>
                  <p>This named parameter can be used to suppress output of the
          <span class="acronym">XML</span> declaration. The default is "no".</p>
                </dd>
                <dt><i class="parameter"><tt>encoding</tt></i></dt>
                <dd>
                  <p>This named parameter controls the character encoding to use.
          (The default is UTF-8.) The writer will automatically use character
          entities where necessary.</p>
                </dd>
                <dt><i class="parameter"><tt>standalone</tt></i></dt>
                <dd>
                  <p>Set this named parameter to "yes" to set standalone in the
          <span class="acronym">XML</span> declaration.</p>
                </dd>
                <dt><i class="parameter"><tt>mediaType</tt></i></dt>
                <dd>
                  <p>This parameter sets the media type of the output. You will
          probably never need this.</p>
                </dd>
                <dt><i class="parameter"><tt>cdataSectionElements</tt></i></dt>
                <dd>
                  <p>This named parameter is a list of element names whose output
          will be wrapped in a CDATA section. This can provide for friendlier
          output in some cases.</p>
                </dd>
              </dl>
            </div>
            <p>The <span class="acronym">XSLT</span> spec also defines a method parameter to
    choose between <span class="acronym">XML</span>, <span class="acronym">HTML</span> or plain
    text output rules, but for <tt class="classname">MarkupWriter</tt> at the
    moment you should stick to <span class="acronym">XML</span>. The result of changing
    the method is undefined. We'll probably relax this restriction in later
    releases.</p>
          </div>
          <div class="section" id="mwriter.examples"><a id="mwriter.examples" name="mwriter.examples"></a>
            <div>
              <h2 class="title"><span class="section-number">8.9 </span>More examples</h2>
            </div>
            <div class="section" id="mwriter.examples.xhtml"><a id="mwriter.examples.xhtml" name="mwriter.examples.xhtml"></a>
              <div>
                <h3 class="title"><span class="section-number">8.9.1 </span>Writing XHTML with <tt class="classname">MarkupWriter</tt></h3>
              </div>
              <p>Uche Ogbuji provides <a href="http://copia.ogbuji.net/blog/2005-08-01/Another_sm">this
      example</a>, which writes a simple XHTML file, in his blog:</p>
              <div class="programlisting">
                <pre>from Ft.Xml.MarkupWriter import MarkupWriter
from xml.dom import XHTML_NAMESPACE, XML_NAMESPACE

XHTML_NS = unicode(XHTML_NAMESPACE)
XML_NS = unicode(XML_NAMESPACE)
XHTML11_SYSID = u"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"
XHTML11_PUBID = u"-//W3C//DTD XHTML 1.1//EN"

writer = MarkupWriter(indent=u"yes", doctypeSystem=XHTML11_SYSID,
                      doctypePublic=XHTML11_PUBID)
writer.startDocument()
writer.startElement(u'html', XHTML_NS, attributes={(u'xml:lang', XML_NS): u'en'})
writer.startElement(u'head', XHTML_NS)
writer.simpleElement(u'title', XHTML_NS, content=u'Virtual Library')
writer.endElement(u'head', XHTML_NS)
writer.startElement(u'body', XHTML_NS)
writer.startElement(u'p', XHTML_NS)
writer.text(u'Moved to ')
writer.simpleElement(u'a', XHTML_NS,
                     attributes={u'href': u'http://vlib.org/'},
                     content=u'vlib.org')
writer.text(u'.')
writer.endElement(u'p', XHTML_NS)
writer.endElement(u'body', XHTML_NS)
writer.endElement(u'html', XHTML_NS)
writer.endDocument()</pre>
              </div>
              <p>This example results in the following XHTML document:</p>
              <div class="screen">
                <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Virtual Library&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Moved to &lt;a href="http://vlib.org/"&gt;vlib.org&lt;/a&gt;.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;  </pre>
              </div>
            </div>
            <div class="section" id="mwriter.examples.dirlist"><a id="mwriter.examples.dirlist" name="mwriter.examples.dirlist"></a>
              <div>
                <h3 class="title"><span class="section-number">8.9.2 </span>Writing information of directory listing as a
      <span class="acronym">XML</span> document</h3>
              </div>
              <p>This recursive example builds an <span class="acronym">XML</span> document
      with the information of a directory listing. The example has two
      functions. The first initializes the writer. The second walks through
      the filesystem and outputs information about the filesystem as
      <span class="acronym">XML</span>. The complete <a href="http://copia.ogbuji.net/files/dirlist.py">dirlist.py
      program</a> can be found on Uche Ogbuji's blog.</p>
              <div class="programlisting">
                <pre>def genXML(dir,out):
    print "Processing %s" % dir
    writer = MarkupWriter(out, indent=u"yes")
    writer.startDocument()
    recurse_dir(dir,writer)

def recurse_dir(path,writer,d):
    d=d+1
    for cdir, subdirs, files in os.walk(path):
        writer.startElement(u'directory', attributes={u'name': unicode(cdir)})
        for f in files:
            writer.simpleElement(u'file', attributes={u'name': unicode(f)})
        for subdir in subdirs: recurse_dir(os.path.join(cdir, subdir), writer,d)
        writer.endElement(u'directory')
        break</pre>
              </div>
            </div>
            <div class="section"><a id="id3057309740L" name="id3057309740L"></a>
              <div>
                <h3 class="title"><span class="section-number">8.9.3 </span>Building a bot</h3>
              </div>
              <p>As a more complex example, the <a href="http://metacognition.info/Emeka/Emeka.py">Emeka
      <span class="acronym">IRC</span> bot</a> uses
      <tt class="classname">MarkupWriter</tt> to build an RDF document. It writes
      namespaces. See this chunk of the code: 
                <div class="programlisting">
                  <pre>DCE_NS = u'http://purl.org/dc/elements/1.1/'
for nada,category in item['categories']:
    if len(category.split(' ')) &gt; 0:
        for category in category.split(' '):
            writer.startElement(u"dc:subject", DCE_NS)
            writer.text(category)
            writer.endElement(u"dc:subject")
    else:
        writer.startElement(u"dc:subject", DCE_NS)
        writer.text(category)
        writer.endElement(u"dc:subject", DCE_NS)</pre>
                </div>
              </p>
            </div>
          </div>
        </div>
        <div class="section" id="RELAXNG"><a id="RELAXNG" name="RELAXNG"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">9 </span>Validation using RELAX NG</h1>
          </div>
          <p>4Suite has RELAX NG support based on a bundling of Eric van der
  Vlist's <a href="http://www.advogato.org/proj/xvif/">XVIF
  implementation</a>.</p>
          <p>First of all, you can use the 4xml command line for RELAX NG
  validation with the --rng flag. For instance, take the following RELAX NG
  schema (rng-tut3.rng):</p>
          <div class="programlisting">
            <pre>&lt;element name="addressBook" xmlns="[http://relaxng.org/ns/structure/1.0][13]"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</pre>
          </div>
          <p>The following document (rng-tut1.xml) is valid against the
  schema:</p>
          <div class="programlisting">
            <pre>&lt;addressBook&gt;
  &lt;card&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</pre>
          </div>
          <p>As you can check as follows:</p>
          <div class="screen">
            <pre>$ 4xml --rng=rng-tut3.rng rng-tut1.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;addressBook&gt;
  &lt;card&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</pre>
          </div>
          <p>Since it passes the schema, 4xml continues normal operation,
  re-serializing the XML back to stdout.</p>
          <p>The following document (rng-tut7.xml) is not valid against the
  schema:</p>
          <div class="programlisting">
            <pre>&lt;addressBook&gt;i
  &lt;card&gt;
    &lt;givenName&gt;John&lt;/givenName&gt;
    &lt;familyName&gt;Smith&lt;/familyName&gt;
  &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</pre>
          </div>
          <p>Which you can check as follows:</p>
          <div class="screen">
            <pre>$ 4xml --rng=rng-tut7.rng rng-tut1.xml 
Traceback (most recent call last):
  File "/home/uogbuji/lib/python2.2/site-packages/Ft/Share/Bin/4xml", line 5, in ?
    XmlCommandLineApp().run()
  File "/home/uogbuji/lib/python2.2/site-packages/Ft/Lib/CommandLine/CommandLineApp.py", line 90, in run
    cmd.run_command(self.authenticationFunction)
  File "/home/uogbuji/lib/python2.2/site-packages/Ft/Lib/CommandLine/Command.py", line 83, in run_command
    self.function(self.clOptions, self.clArguments)
  File "/home/uogbuji/lib/python2.2/site-packages/Ft/Xml/_4xml.py", line 89, in Run
    raise RngInvalid(result)
Ft.Xml.Xvif.RngInvalid: _Pattern Empty, no content expected, 
node &lt;cElement at 0x838d7f4: name u'card', 0 attributes, 7 children&gt;</pre>
          </div>
          <p>The exception is for the invalid pattern.</p>
          <p>You can also access validation through the Python API using the new
  Ft.Xml.Xvif.RelaxNgValidator class. For example:</p>
          <div class="programlisting">
            <pre>from Ft.Xml.Xvif import RelaxNgValidator
from Ft.Xml import InputSource
from Ft.Lib import Uri
factory = InputSource.DefaultFactory
rng_uri = Uri.OsPathToUri("rng-tut3.rng", attemptAbsolute=1)
src_uri = Uri.OsPathToUri("rng-tut1.xml", attemptAbsolute=1)
rng_isrc = factory.fromUri(rng_uri)
src_isrc = factory.fromUri(src_uri)

validator = RelaxNgValidator(rng_isrc)
result = validator.isValid(src_isrc)
if result:
    print "Valid"
else:
    print "Invalid"</pre>
          </div>
          <p>The isValid() method returns a 1 or 0 for validity. To get the actual
  structure returned by the validator, use the validate() method instead. This
  structure can easily be turned into an exception object. The following
  variation prints "Valid" if valid, and raises an exception if not:</p>
          <div class="programlisting">
            <pre>from Ft.Xml.Xvif import RelaxNgValidator, RngInvalid
from Ft.Xml import InputSource
factory = InputSource.DefaultFactory
from Ft.Lib import Uri
factory = InputSource.DefaultFactory
rng_uri = Uri.OsPathToUri("rng-tut3.rng", attemptAbsolute=1)
src_uri = Uri.OsPathToUri("rng-tut1.xml", attemptAbsolute=1)
rng_isrc = factory.fromUri(rng_uri)
src_isrc = factory.fromUri(src_uri)

validator = RelaxNgValidator(rng_isrc)
result = validator.validate(src_isrc)
if result.nullable():
    print "Valid"
else:
    raise RngInvalid(result)</pre>
          </div>
          <p>If you want to use the validation error message without raising an
  exception:</p>
          <div class="programlisting">
            <pre># Set-up as above
result = validator.validate(src_isrc)
if result.nullable():
    print "Valid"
else:
    print result.msg</pre>
          </div>
        </div>
        <div class="section" id="xupdate"><a id="xupdate" name="xupdate"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">10 </span>XUpdate processing</h1>
          </div>
          <p><a href="http://xmldb-org.sourceforge.net/xupdate/">XUpdate</a> is
  a community specification for using an XML vocabulary to express
  modifications to XML documents. It is essentially an XPath-based XML
  transformation language, like XSLT. An XUpdate document is an XML document
  that specifies what changes should be made to another XML document. XUpdate
  is supported by many XML processing tools - especially in the open source
  category - and XUpdate is neither a W3C Recommendation nor an ISO or IETF
  standard. It is just a project of the XML:DB Initiative's XUpdate Working
  Group, and it never advanced beyond a Working Draft published in September,
  2000. It is not very well specified, but it is very convenient and enables a
  basic level of functionality, so it has enjoyed popularity in a number of
  implementations.</p>
          <p>4Suite's XUpdate implementation, 4XUpdate, consists of a Python API
  (via the Ft.Xml.XUpdate module) and a command-line script (4xupdate). The
  APIs involve taking a source document (the XML to be updated) and an XUpdate
  document (the changes to apply), and either producing a new document or
  updating the source document in-place. The command line tool can be used,
  for example, as a patching utility for XML. All of XUpdate (such as it's
  specified) is currently implemented.</p>
          <p>The Python API can be invoked directly on Domlette objects or on
  InputSources. Here is an example of using the ApplyXUpdate convenience
  function, which takes InputSources:</p>
          <div class="programlisting">
            <pre>from Ft.Xml.Domlette import PrettyPrint
from Ft.Xml.InputSource import DefaultFactory
try:
    from Ft.Xml.XUpdate import ApplyXUpdate
except ImportError:
    # the function name changed between 1.0a3 and 1.0b1
    from Ft.Xml.XUpdate import ApplyXupdate as ApplyXUpdate

SOURCE='''&lt;?xml version = "1.0"?&gt;
&lt;ADDRBOOK xmlns="http://bogus/"&gt;
  &lt;ENTRY ID="fr"&gt;
    &lt;NAME&gt;fred&lt;/NAME&gt;
  &lt;/ENTRY&gt;
&lt;/ADDRBOOK&gt;'''

XU='''&lt;?xml version="1.0"?&gt;
&lt;xu:modifications version="1.0" xmlns:xu="http://www.xmldb.org/xupdate"
  xmlns:myns="http://bogus/"&gt;
  &lt;xu:append select="/myns:ADDRBOOK" child="last()"&gt;
    &lt;ENTRY ID="vz"&gt;
      &lt;NAME&gt;Vasia Zhugenev&lt;/NAME&gt;
    &lt;/ENTRY&gt;
  &lt;/xu:append&gt;
&lt;/xu:modifications&gt;'''

src_isrc = DefaultFactory.fromString(SOURCE, "http://test1/")
xup_isrc = DefaultFactory.fromString(XU, "http://test2/")

result_dom = ApplyXUpdate(src_isrc, xup_isrc)
PrettyPrint(result_dom)

#expected:
#&lt;?xml version="1.0" encoding="UTF-8"?&gt;
#&lt;ADDRBOOK xmlns="http://bogus/"&gt;
#  &lt;ENTRY ID="fr"&gt;
#    &lt;NAME&gt;fred&lt;/NAME&gt;
#  &lt;/ENTRY&gt;
#&lt;ENTRY ID="vz"&gt;
#    &lt;NAME&gt;Vasia Zhugenev&lt;/NAME&gt;
#  &lt;/ENTRY&gt;
#&lt;/ADDRBOOK&gt;</pre>
          </div>
          <p>If you have both the source document and XUpdate document as Domlette
  nodes already, you can use the XUpdate processor directly:</p>
          <div class="programlisting">
            <pre># add to the above script...
from Ft.Xml.Domlette import NonvalidatingReader
from Ft.Xml.XUpdate import Processor
src_isrc = DefaultFactory.fromString(SOURCE, "http://test1/")
xup_isrc = DefaultFactory.fromString(XU, "[http://test2/")
src_dom = NonvalidatingReader.parse(src_isrc)
xup_dom = NonvalidatingReader.parse(xup_isrc)
proc = Processor()
proc.execute(src_dom, xup_dom)

# src_dom has been modified in-place
PrettyPrint(src_dom)</pre>
          </div>
          <p>Using the processor directly allows you to set XPath variables, if
  needed:</p>
          <div class="programlisting">
            <pre>from Ft.Xml import EMPTY_NAMESPACE

# execute with $x='foo'
proc.execute(src_dom, xup_dom, {(EMPTY_NAMESPACE, u'x'): u'foo'})</pre>
          </div>
          <p>The command-line script works on local files or even URIs, if
  resolvable, and normally sends the result XML to standard output, although
  it can also be made to write to a file. See "4xupdate -h" for usage
  instructions.</p>
          <div class="section"><a id="id3057324396L" name="id3057324396L"></a>
            <div>
              <h2 class="title"><span class="section-number">10.1 </span>XUpdate and namespaces</h2>
            </div>
            <p>In order to show how to use XUpdate to make namespace-aware
    modifications, The following tasks will be demonstrated:</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>Add a new element in the products namespace, but using no
        prefix.</p>
              </li>
              <li>
                <p>Add a new element with a prefix and in the products
        namespace.</p>
              </li>
              <li>
                <p>Add a new element that is not in any namespace.</p>
              </li>
              <li>
                <p>Add a new global attribute in the XHTML namespace.</p>
              </li>
              <li>
                <p>Add a new global attribute in the special XML namespace.</p>
              </li>
              <li>
                <p>Add a new attribute in no namespace.</p>
              </li>
              <li>
                <p>Remove only the <tt class="literal">code</tt> element in the XHTML
        namespace</p>
              </li>
              <li>
                <p>Remove a global attribute</p>
              </li>
              <li>
                <p>Remove an attribute that is not in any namespace</p>
              </li>
            </ol>
            <p>Modification in place can always be simulated with an addition and
    then a removal. The following code shows how these tasks can be performed
    in XUpdate.</p>
            <div class="programlisting">
              <pre>&lt;xup:modifications version="1.0"
  xmlns:xup="http://www.xmldb.org/xupdate"
  xmlns:p="http://example.com/product-info"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:xl="http://www.w3.org/1999/xlink"
&gt;

  &lt;!-- Task 1 --&gt;
  &lt;xup:append select="/products/p:product[1]"&gt;
    &lt;xup:element
      name="launch-date"
      namespace="http://example.com/product-info"/&gt;
  &lt;/xup:append&gt;

  &lt;!-- Task 2 --&gt;
  &lt;xup:append select="/products/p:product[1]"&gt;
    &lt;xup:element
      name="p:launch-date"
      namespace="http://example.com/product-info"/&gt;
  &lt;/xup:append&gt;

  &lt;!-- Can also be accomplished using literal result elements:
  &lt;xup:append select="/products/p:product[1]"&gt;
    &lt;p:launch-date/&gt;
  &lt;/xup:append&gt;
  --&gt;

  &lt;!-- Task 3 --&gt;
  &lt;xup:append select="/products/p:product[1]"&gt;
    &lt;xup:element name="island"/&gt;
  &lt;/xup:append&gt;

  &lt;!-- Can also be accomplished using literal result elements:
  &lt;xup:append select="/products/p:product[1]"&gt;
    &lt;island/&gt;
  &lt;/xup:append&gt;
  --&gt;

  &lt;!-- Task 4 --&gt;
  &lt;xup:append select="/products/p:product/p:description/html:div"&gt;
    &lt;xup:attribute name="global"
      namespace="http://www.w3.org/1999/xhtml"&gt;spam&lt;/xup:attribute&gt;
  &lt;/xup:append&gt;

  &lt;!-- Task 5 --&gt;
  &lt;xup:append select="/products/p:product/p:description/html:div"&gt;
    &lt;xup:attribute name="xml:lang"&gt;en&lt;/xup:attribute&gt;
  &lt;/xup:append&gt;

  &lt;!-- Task 6 --&gt;
  &lt;xup:append select="/products/p:product/p:description/html:div"&gt;
    &lt;xup:attribute name="class"&gt;eggs&lt;/xup:attribute&gt;
  &lt;/xup:append&gt;

  &lt;!-- Task 7 --&gt;
  &lt;xup:remove select="//html:code"/&gt;

  &lt;!-- Task 8 --&gt;
  &lt;xup:remove select="/products/p:product/p:description/html:div/ref/@xl:href"/&gt;

  &lt;!-- Task 9 --&gt;
  &lt;xup:remove select="/products/p:product[1]/@id"/&gt;

&lt;/xup:modifications&gt;</pre>
            </div>
            <p>If you're familiar with XSLT, then you'll see the resemblance of
    XUpdate at first glance. The envelope element for modifications expressed
    in XUpdate is <tt class="literal">xup:modifications</tt>, similar to
    <tt class="literal">xsl:transform</tt> or <tt class="literal">xsl:stylesheet</tt>. The
    namespace declarations on this element assign prefixes for use in the
    XUpdate script and <strong class="emphasis">have no connection</strong>
    to the prefixes used in the document being modified (the <strong class="emphasis">source document</strong>), even though they happen to be
    the same. If you want to access elements in a namespace declared as the
    default in the source document, then just as in XSLT you must declare and
    use a prefix for the namespace in the XUpdate script.</p>
            <p>Each modification request is expressed as an XUpdate instruction.
    This example demonstrates <tt class="literal">xup:append</tt> and
    <tt class="literal">xup:remove</tt>. There are other instructions providing
    types of modification such as <tt class="literal">xup:insert-before</tt>
    <tt class="literal">xup:update</tt> and there are also control constructs such
    as <tt class="literal">xup:if</tt>, which is similar to
    <tt class="literal">xsl:if</tt>. Instructions usually have a
    <tt class="literal">select</tt> attribute containing an XPath expression that
    specifies the node to be used as a reference for modification. In the case
    of <tt class="literal">xup:append</tt>, <tt class="literal">select</tt> specifies a
    node after which some new XML will be appended. In the case of
    <tt class="literal">xup:remove</tt>, <tt class="literal">select</tt> identifies nodes
    to be removed. When an instruction needs to specify a chunk of XML to be
    used in the modification it is expressed as the content of the
    instructions in a similar fashion to XSLT templates. In the case of
    <tt class="literal">xup:append</tt> this template expresses the chunk of XML to
    be inserted into the document. In order to generate elements and
    attributes XUpdate provides output instructions such as
    <tt class="literal">xup:element</tt> and <tt class="literal">xup:attribute</tt>, which
    are very similar to their XSLT equivalents. In another idea borrowed from
    XSLT, XUpdate allows you to create element by placing literal result
    elements in the templates. If you'd like to get a closer look at XUpdate,
    the best way is by browsing the very clear examples in the <a href="http://www.xmldatabases.org/projects/XUpdate-UseCases/">XUpdate Use
    Cases</a> compiled by Kimbro Staken. The following listing is a Python
    code that can be used to apply an XUpdate script. It's a simplified
    version of the code for the 4xupdate command line.</p>
            <div class="programlisting">
              <pre>import sys
from Ft.Xml import XUpdate
from Ft.Xml import Domlette, InputSource
from Ft.Lib import Uri

# Set up reader objects for parsing the XML files
reader = Domlette.NonvalidatingReader
xureader = XUpdate.Reader()

# Parse the source file
source_uri = Uri.OsPathToUri(sys.argv[1], attemptAbsolute=1)
source = reader.parseUri(source_uri)

# Parse the XUpdate file
xupdate_uri = Uri.OsPathToUri(sys.argv[2], attemptAbsolute=1)
isrc = InputSource.DefaultFactory.fromUri(xupdate_uri)
xupdate = xureader.fromSrc(isrc)

# Set up the XUpdate processor and run against the source file
# The Domlette for the source is modified in place
processor = XUpdate.Processor()
processor.execute(source, xupdate)

# Print the updated DOM node to standard output
Domlette.Print(source)</pre>
            </div>
            <p>Notice the use of <tt class="literal">Uri.OsPathToUri</tt> to convert file
    system paths to proper URIs for use in 4Suite. I strongly recommend this
    convention as one way to help minimize confusion between file
    specifications and URIs -- the basis of many frequently asked questions.
    The <tt class="literal">XUpdate.Processor</tt> class defines the environment for
    running XUpdate commands and <tt class="literal">execute()</tt> is the method
    that actually kicks off the processing. It operates on a Domlette
    instance, modifying it in place (so be careful when using using XUpdate in
    this way). The updated document object is printed to standard output using
    <tt class="literal">Domlette.Print</tt>.</p>
            <p>The following snippet illustrates how to run the test script, and
    the output result.</p>
            <div class="programlisting">
              <pre>$ python listing4.py products.xml listing3.xup
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;products xmlns:p="http://example.com/product-info"
xmlns:html="http://www.w3.org/1999/xhtml"
xmlns:xl="http://www.w3.org/1999/xlink"
&gt;
  &lt;product xmlns="http://example.com/product-info"&gt;
    &lt;name xml:lang="en"&gt;Python Perfect IDE&lt;/name&gt;
    &lt;description&gt;
      Uses mind-reading technology to anticipate and accommodate
      all user needs in Python development.  Implements all
       features though
      the year 3000.  Works well with &lt;code&gt;1166&lt;/code&gt;.
    &lt;/description&gt;
  &lt;launch-date/&gt;&lt;p:launch-date/&gt;&lt;island/&gt;&lt;/product&gt;
  &lt;p:product id="1166"&gt;
    &lt;p:name&gt;XSLT Perfect IDE&lt;/p:name&gt;
    &lt;p:description&gt;
      &lt;p:code&gt;red&lt;/p:code&gt;
      &lt;html:code&gt;blue&lt;/html:code&gt;
      &lt;html:div global="spam" class="eggs" xml:lang="en"&gt;
        &lt;ref xl:type="simple"&gt;A link&lt;/ref&gt;
      &lt;/html:div&gt;
    &lt;/p:description&gt;
  &lt;/p:product&gt;
&lt;/products&gt;</pre>
            </div>
          </div>
        </div>
        <div class="section" id="xinclude"><a id="xinclude" name="xinclude"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">11 </span>XInclude processing</h1>
          </div>
          <div class="section" id="about_xinclude"><a id="about_xinclude" name="about_xinclude"></a>
            <div>
              <h2 class="title"><span class="section-number">11.1 </span>About XInclude</h2>
            </div>
            <p><a href="http://www.w3.org/TR/xinclude/">XML Inclusions
    (XInclude)</a> is a W3C Recommendation that provides XML document
    authors with a robust way of supporting document modularity via the use
    of <a href="http://en.wikipedia.org/wiki/Transclusion">transclusions</a>
    (inclusions by reference). Such modularity would otherwise require using
    references to external entities declared in a DTD, a system which has
    various limitations inherited from SGML.</p>
            <p>Unlike XML's built-in entity-reference system, the processing of
    XIncludes is, fundamentally, an XML Infoset transformation, not strictly
    an operation performed on the serialized (textual) form of a document.
    Therefore, there is no requirement for when and where XInclude
    processing should occur; it could happen at parse time if the parser
    supports it, or could occur on an already-parsed document.</p>
            <p>XInclude references consist of two special elements that are
    placed in the XML document into which external content is to be
    included: <tt class="code">&lt;include&gt;</tt> and
    <tt class="code">&lt;fallback&gt;</tt>, both in the namespace
    <tt class="literal">http://www.w3.org/2001/XInclude</tt>. When processed,
    these elements are replaced with the content they reference, which can
    be XML or any other text.</p>
          </div>
          <div class="section" id="xinclude_in_4suite"><a id="xinclude_in_4suite" name="xinclude_in_4suite"></a>
            <div>
              <h2 class="title"><span class="section-number">11.2 </span>XInclude support in 4Suite</h2>
            </div>
            <p>4Suite supports XInclude processing only at parse time, as an
    optional feature of the Domlette readers. It is turned on by default, so
    if you want to suppress it, you must use the full parsing API &mdash; not
    the <tt class="methodname">Ft.Xml.Parse</tt> and
    <tt class="methodname">Ft.Xml.CreateInputSource</tt> convenience functions
    &mdash; and set the parameter <i class="parameter"><tt>processIncludes</tt></i> to
    <tt class="literal">False</tt> either when creating an
    <tt class="classname">InputSource</tt> or when calling the
    <tt class="methodname">parseString</tt>, <tt class="methodname">parseUri</tt>,
    or <tt class="methodname">parseStream</tt> method of the Domlette
    reader.</p>
          </div>
          <div class="section" id="xinclude_examples"><a id="xinclude_examples" name="xinclude_examples"></a>
            <div>
              <h2 class="title"><span class="section-number">11.3 </span>Examples</h2>
            </div>
            <p>The following example includes one section stub into a larger
    article but has to use the fallback for the second section stub, where
    resolution fails. <a href="#xinclude.example.main_doc" title="Document using XInclude">&ldquo;Document using XInclude&rdquo;</a> lists the
    contents of the file <tt class="filename">article.xml</tt>, which references
    two sections using XInclude and provides a fallback for each in case
    they fail to load. <a href="#xinclude.example.included_section" title="Section to be included">&ldquo;Section to be included&rdquo;</a>
    lists the contents of <tt class="filename">section1.xml</tt>, but this
    example purposefully does not provide a
    <tt class="filename">section2.xml</tt> in order to illustrate the fallback
    behaviour. <a href="#xinclude.example.load" title="Loading the document">&ldquo;Loading the document&rdquo;</a> lists the Python
    code used to parse and print this document; note that XInclude
    processing is done automatically by default.</p>
            <div class="$" id="xinclude.example.main_doc"><a name="id3057338220L"></a>
              <div class="programlisting">
                <pre>&lt;article&gt;
  &lt;title&gt;My important article&lt;/title&gt;
  &lt;xi:include href="section1.xml" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
    &lt;xi:fallback&gt;&lt;!-- Section 1 failed to load! --&gt;&lt;/xi:fallback&gt;
  &lt;/xi:include&gt;
  &lt;xi:include href="section2.xml" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
    &lt;xi:fallback&gt;&lt;!-- Section 2 failed to load! --&gt;&lt;/xi:fallback&gt;
  &lt;/xi:include&gt;
&lt;/article&gt;</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;1 &mdash; Document using XInclude</b></p>
            </div>
            <div class="$" id="xinclude.example.included_section"><a name="id3057338412L"></a>
              <div class="programlisting">
                <pre>&lt;section&gt;
  &lt;title&gt;Section 1&lt;/title&gt;
  &lt;!-- Write me! --&gt;
&lt;/section&gt;</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;2 &mdash; Section to be included</b></p>
            </div>
            <div class="$" id="xinclude.example.load"><a name="id3057338604L"></a>
              <div class="programlisting">
                <pre>from Ft.Xml import Parse
from Ft.Xml.Domlette import PrettyPrint
doc = Parse("article.xml")
PrettyPrint(doc)</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;3 &mdash; Loading the document</b></p>
            </div>
            <p><a href="#xinclude.example.complete" title="Self-contained example">&ldquo;Self-contained example&rdquo;</a> is very similar to
    the above example, only this version is self-contained; the resources
    are stored in Python strings and resolved using a custom
    resolver.</p>
            <div class="$" id="xinclude.example.complete"><a name="id3057338924L"></a>
              <div class="programlisting">
                <pre>article = """&lt;article&gt;&lt;title&gt;My important article&lt;/title&gt;
&lt;xi:include href="ex:section" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
  &lt;xi:fallback&gt;&lt;!-- Section 1 failed to load! --&gt;&lt;/xi:fallback&gt;
&lt;/xi:include&gt;
&lt;xi:include href="ex:section2" xmlns:xi="http://www.w3.org/2001/XInclude"&gt;
  &lt;xi:fallback&gt;&lt;!-- Section 2 failed to load! --&gt;&lt;/xi:fallback&gt;
&lt;/xi:include&gt;
&lt;/article&gt;"""

section = "&lt;section&gt;&lt;title&gt;Section 1&lt;/title&gt;&lt;!-- Write me! --&gt;&lt;/section&gt;"

from Ft.Lib.Uri import FtUriResolver, Absolutize
from Ft.Lib import UriException
from cStringIO import StringIO
class MyResolver (FtUriResolver):
  def normalize(self, uriRef, baseUri):
    return Absolutize(uriRef, baseUri)
  def resolve(self, uri):
    if uri == "ex:article":
      return StringIO(article)
    elif uri == "ex:section":
      return StringIO(section)
    else:
      raise UriException(UriException.RESOURCE_ERROR,
                         loc=uri, msg="not found, sorry")

myResolver = MyResolver()

from Ft.Xml.InputSource import InputSourceFactory
from Ft.Xml.Domlette import NonvalidatingReader, PrettyPrint
factory = InputSourceFactory(resolver=myResolver)
isrc = factory.fromUri("ex:article")
doc = NonvalidatingReader.parse(isrc)
PrettyPrint(doc)</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;4 &mdash; Self-contained example</b></p>
            </div>
            <p>To turn off XInclude behavior in <a href="#xinclude.example.complete" title="Self-contained example">&ldquo;Self-contained example&rdquo;</a>, replace the last three lines
    with these three lines:</p>
            <div class="programlisting">
              <pre>isrc = factory.fromUri("ex:article", processIncludes=False)
doc = NonvalidatingReader.parse(isrc)
PrettyPrint(doc)</pre>
            </div>
            <p><a href="#xinclude.example.load" title="Loading the document">&ldquo;Loading the document&rdquo;</a> uses the "super simple"
    parsing API; we need to use the full parsing API in order to disable
    XInclude expansion (which, paradoxically, takes one less line):</p>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import NonvalidatingReader, PrettyPrint
doc = NonvalidatingReader.parseStream(file("article.xml"), processIncludes=False)
PrettyPrint(doc)</pre>
            </div>
          </div>
        </div>
        <div class="section" id="xpointer"><a id="xpointer" name="xpointer"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">12 </span>XPointer processing</h1>
          </div>
          <div class="section" id="about_xpointer"><a id="about_xpointer" name="about_xpointer"></a>
            <div>
              <h2 class="title"><span class="section-number">12.1 </span>About XPointer</h2>
            </div>
            <p><a href="http://www.w3.org/TR/xptr-framework/">XPointer</a>
    is a set of W3C specifications (one part of which is, as of 2006, still
    a Working Draft) that provide a means of identifying and referring to a
    portion of an XML document. The portion being referenced need not be
    contiguous, and need not constitute a well-formed general entity.
    XPointers were originally intended to be used in the fragment component
    of a URI or IRI (the fragment being the part after
    "<tt class="literal">#</tt>"), but the specifications actually place no
    restrictions on where they can be used.</p>
            <p>An example of an XPointer embedded in a URI would be</p>
            <p><tt class="literal">http://example.com/inventory.xml#xpointer(//part%5Bstarts-with(sku,%20'999')%5D)</tt></p>
            <p>The XPointer in that example is actually</p>
            <p><tt class="literal">xpointer(//part[starts-with(sku,
    '999')])</tt></p>
            <p>but the URI syntax requires further encoding of some data. The
    result of evaluating this XPointer would be the same as evaluating the
    XPath expression <tt class="code">//part[starts-with(sku, '999')]</tt> against
    the document identified by the URI
    <tt class="literal">http://example.com/inventory.xml</tt>.</p>
            <p>XPointer syntax is simple: a <i class="firstterm">shorthand
    XPointer</i> is just a name, and refers to the element with that
    ID (as determined by a DTD or other schema, typically), much like the
    XPath 1.0 expression <tt class="code">id(somename)</tt>, but with a little more
    flexibility, since <tt class="code">id()</tt> is limited to DTD-based data
    typing.</p>
            <p>A <i class="firstterm">scheme-based XPointer</i> consists of a
    series of one or more <i class="firstterm">parts</i>,
    separated by optional whitespace, with each part looking like a function
    call. What appear to be function names are actually syntactic and
    semantic <i class="firstterm">schemes</i>, of which the most common is the
    ID-oriented <tt class="literal">element</tt> scheme, and of which the most
    versatile is the XPath-oriented <tt class="literal">xpointer</tt>
    scheme.</p>
            <p>If a scheme-based XPointer contains more than one part, then the
    parts are evaluated from left to right, skipping any
    unsupported/unrecognized schemes, until one is found that identifies
    something that exists in the document. Some schemes, like the
    namespace/prefix-binding <tt class="literal">xmlns</tt>, identify nothing (by
    design), and instead just influence the interpretation of subsequent
    parts. It's possible for an XPointer to produce different results with
    different processors, if the author doesn't take care to ensure each
    part identifies the same thing.</p>
            <p>Here are some more examples:</p>
            <p>The XPath 1.0 expression <tt class="code">id(somename)</tt> means the same
    thing as the XPointer <tt class="code">xpointer(id(somename))</tt>, and nearly
    the same thing as the XPointers <tt class="code">element(somename)</tt> and
    <tt class="code">somename</tt>, which just have more flexibility in where the ID
    can be drawn from.</p>
            <p>The XPointer <tt class="code">element(somename/3/1)</tt> means nearly the
    same thing as the XPath expression
    <tt class="code">id(somename)/*[3]/*[1]</tt>.</p>
            <p>The XPointer
    <tt class="code">xmlns(xhtml=http://www.w3.org/1999/xhtml)xpointer(//xhtml:a[@href])</tt>
    could be used to refer to all of the links in an XHTML 1.0
    document.</p>
          </div>
          <div class="section" id="xpointer_in_4suite"><a id="xpointer_in_4suite" name="xpointer_in_4suite"></a>
            <div>
              <h2 class="title"><span class="section-number">12.2 </span>XPointer support in 4Suite</h2>
            </div>
            <p>4Suite's XPointer implementation, sometimes called 4XPointer, has
    no command-line interface, but can be used within Python applications.
    It supports XPointers to different degrees, depending on the
    circumstances:</p>
            <ol style="list-style-type: decimal; list-style-position: outside;">
              <li>
                <p>When an XML document is being parsed into a Domlette with
        XInclude processing enabled, any XPointer encountered in an
        <tt class="code">xi:include</tt> element is automatically evaluated when the
        included document is parsed. In this mode the XPointer must use an
        XPath LocationPath that only uses steps along the child axis.
        Furthermore, any predicates must be literal numbers, or must be of
        the specific form <tt class="code">[@attname='attvalue']</tt>. For example,
        <tt class="code">/foo[3]</tt> and <tt class="code">/foo[@bar='baz']</tt> will work,
        but <tt class="code">../foo</tt> and <tt class="code">foo/[.='bar']</tt> will not.
        Function calls are not allowed.</p>
              </li>
              <li>
                <p>If you have not yet parsed an XML document, but have a URI for
        it, then you can use
        <tt class="methodname">Ft.Xml.XPointer.SelectUri</tt>() to parse the
        document and evaluate an XPointer embedded in the URI's fragment
        component. The parsing is performed with Domlette's default
        <tt class="classname">NonvalidatingReader</tt> instance. There are some
        implementation gaps to note when using the
        <tt class="literal">xpointer</tt> scheme: the only additional function
        fully supported is <tt class="methodname">here</tt>(), and the
        following functions always return empty location-sets:
        <tt class="methodname">string-range</tt>(),
        <tt class="methodname">range-to</tt>(),
        <tt class="methodname">start-point</tt>(),
        <tt class="methodname">end-point</tt>(), and
        <tt class="methodname">origin</tt>(). <tt class="methodname">origin</tt>
        is illegal to use outside of extended XLinks, anyway.</p>
              </li>
              <li>
                <p>If you have already parsed the document into a Domlette, then
        you can evaluate an arbitrary XPointer against it by using
        <tt class="methodname">Ft.Xml.XPointer.SelectNode</tt>(). The same
        implementation gaps as noted in the description of
        <tt class="methodname">Ft.Xml.XPointer.SelectUri</tt>() apply.</p>
              </li>
            </ol>
            <p>Ranges are not supported because Domlette does not support DOM
    Level 2 Ranges. Uche Ogbuji posted <a href="http://lists.fourthought.com/pipermail/4suite/2003-September/005813.html">some
    thoughts about this topic</a> a while back. Also note that although
    the <tt class="literal">element</tt> scheme is streamable, it is not yet
    supported in XIncludes due to ID-related limitations in Domlette. Since
    <tt class="literal">element</tt> and shorthand pointer support are
    requirements for full XInclude conformance, they will probably be
    implemented in the future.</p>
            <p>In 4Suite 1.0b1 and earlier, the implementation was based on older
    versions of the specs, and several additional restrictions were in
    effect: the <tt class="literal">element</tt> scheme was not even an option,
    XPointers in XIncludes had to be given via URIs (not attributes) and
    couldn't contain NameTests involving "<tt class="code">*</tt>", and all other
    XPointers were only allowed to identify a single node.</p>
          </div>
          <div class="section" id="xpointer_examples"><a id="xpointer_examples" name="xpointer_examples"></a>
            <div>
              <h2 class="title"><span class="section-number">12.3 </span>Examples</h2>
            </div>
            <p>The following example uses XInclude with XPointer references to
    include various sections from one document into another document. <a href="#xpointer.example.main_doc" title="article.xml: Document using XInclude with&#10;      XPointer references">&ldquo;<tt class="filename">article.xml</tt>: Document using XInclude with
      XPointer references&rdquo;</a> lists the contents of the file
    <tt class="filename">article.xml</tt>, which references one section using a
    shorthand pointer and then references any sections that have their
    <tt class="sgmltag">condition</tt> attribute set to <tt class="sgmltag">unfinished</tt>. <a href="#xpointer.example.referenced_doc" title="article2.xml: Document with content&#10;      referenced from article.xml">&ldquo;<tt class="filename">article2.xml</tt>: Document with content
      referenced from <tt class="filename">article.xml</tt>&rdquo;</a> lists the contents of the
    file <tt class="filename">article2.xml</tt>, which is referenced from
    <tt class="filename">article.xml</tt>. <a href="#xpointer.example.load" title="Loading the document">&ldquo;Loading the document&rdquo;</a> lists the Python code used to parse
    and print this document; note that XPointer processing is driven from
    XInclude processing, which is done automatically by default.</p>
            <div class="$" id="xpointer.example.main_doc"><a name="id3057357484L"></a>
              <div class="programlisting">
                <pre>&lt;article&gt;
  &lt;title&gt;My important article&lt;/title&gt;
  &lt;xi:include href="article2.xml"
              xpointer="woo"
              xmlns:xi="http://www.w3.org/2001/XInclude"/&gt;
  &lt;xi:include href="article2.xml"
              xpointer="xpointer(article/section[@condition='unfinished'])"
              xmlns:xi="http://www.w3.org/2001/XInclude"/&gt;
&lt;/article&gt;</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;5 &mdash; <tt class="filename">article.xml</tt>: Document using XInclude with
      XPointer references</b></p>
            </div>
            <div class="$" id="xpointer.example.referenced_doc"><a name="id3057357804L"></a>
              <div class="programlisting">
                <pre>&lt;article&gt;
  &lt;section condition="unfinished"&gt;
    &lt;title&gt;Section 1&lt;/title&gt;
    &lt;!-- Write me! --&gt;
  &lt;/section&gt;
  &lt;section xml:id="woo"&gt;
    &lt;title&gt;Section 2&lt;/title&gt;
    &lt;para&gt;Yeah, content.&lt;/para&gt;
  &lt;/section&gt;
  &lt;section condition="unfinished"&gt;
    &lt;title&gt;Section 3&lt;/title&gt;
    &lt;!-- Write me, too! --&gt;
  &lt;/section&gt;
&lt;/article&gt;</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;6 &mdash; <tt class="filename">article2.xml</tt>: Document with content
      referenced from <tt class="filename">article.xml</tt></b></p>
            </div>
            <div class="$" id="xpointer.example.load"><a name="id3057358124L"></a>
              <div class="programlisting">
                <pre>from Ft.Xml import Parse
from Ft.Xml.Domlette import PrettyPrint
doc = Parse("article.xml")
PrettyPrint(doc)</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;7 &mdash; Loading the document</b></p>
            </div>
            <p>As mentioned earlier, XPointer is most commonly used along with
    XInclude, but 4Suite provides an API for using XPointer directly from
    Python. Using <tt class="filename">article2.xml</tt> as listed above in <a href="#xpointer.example.referenced_doc" title="article2.xml: Document with content&#10;      referenced from article.xml">&ldquo;<tt class="filename">article2.xml</tt>: Document with content
      referenced from <tt class="filename">article.xml</tt>&rdquo;</a>, <a href="#xpointer.example.direct" title="Using XPointer directly from Python">&ldquo;Using XPointer directly from Python&rdquo;</a> loads two of the nodes loaded
    previously with XInclude. Note that when using the standalone interface,
    the code is able to take advantage of more of the XPointer
    syntax.</p>
            <div class="$" id="xpointer.example.direct"><a name="id3057358572L"></a>
              <div class="programlisting">
                <pre>from Ft.Xml import Parse
from Ft.Xml.Domlette import PrettyPrint
from Ft.Xml.XPointer import SelectNode

article2 = Parse("article2.xml")
# Shorthand XPointer syntax
node = SelectNode(article2, "woo")[0]
PrettyPrint(node)
# Scheme-based XPointer syntax
node = SelectNode(article2,
                  "xpointer(//section[@condition='unfinished'][2])")[0]
PrettyPrint(node)</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;8 &mdash; Using XPointer directly from Python</b></p>
            </div>
            <p><a href="#xpointer.example.complete" title="Self-contained example">&ldquo;Self-contained example&rdquo;</a> is very similar to
    the examples above, only this version is self-contained; the resources
    are stored in Python strings and resolved using a custom
    resolver.</p>
            <div class="$" id="xpointer.example.complete"><a name="id3057358892L"></a>
              <div class="programlisting">
                <pre>article = """&lt;article&gt;&lt;title&gt;My important article&lt;/title&gt;
&lt;xi:include href="ex:article2"
            xpointer="woo"
            xmlns:xi="http://www.w3.org/2001/XInclude"/&gt;
&lt;xi:include href="ex:article2"
            xpointer="xpointer(article/section[@condition='unfinished'])"
            xmlns:xi="http://www.w3.org/2001/XInclude"/&gt;
&lt;/article&gt;"""

article2 = """&lt;article&gt;
&lt;section condition="unfinished"&gt;&lt;title&gt;Section 1&lt;/title&gt;&lt;!-- Write me! --&gt;&lt;/section&gt;
&lt;section xml:id="woo"&gt;&lt;title&gt;Section 2&lt;/title&gt;&lt;para&gt;Yeah, content.&lt;/para&gt;&lt;/section&gt;
&lt;section condition="unfinished"&gt;&lt;title&gt;Section 3&lt;/title&gt;&lt;!-- Write me, too! --&gt;&lt;/section&gt;
&lt;/article&gt;"""

from Ft.Lib.Uri import FtUriResolver, Absolutize
from Ft.Lib import UriException
from cStringIO import StringIO
class MyResolver (FtUriResolver):
  def normalize(self, uriRef, baseUri):
    return Absolutize(uriRef, baseUri)
  def resolve(self, uri):
    if uri == "ex:article":
      return StringIO(article)
    elif uri == "ex:article2":
      return StringIO(article2)
    else:
      raise UriException(UriException.RESOURCE_ERROR,
                         loc=uri, msg="not found, sorry")

myResolver = MyResolver()

from Ft.Xml.InputSource import InputSourceFactory
from Ft.Xml.Domlette import NonvalidatingReader, PrettyPrint
factory = InputSourceFactory(resolver=myResolver)
isrc = factory.fromUri("ex:article")
doc = NonvalidatingReader.parse(isrc)
PrettyPrint(doc)

from Ft.Xml.XPointer import SelectNode

isrc = factory.fromUri("ex:article2")
article2 = NonvalidatingReader.parse(isrc)
node = SelectNode(article2, "woo")[0]
PrettyPrint(node)
node = SelectNode(article2,
                  "xpointer(//section[@condition='unfinished'][2])")[0]
PrettyPrint(node)
</pre>
              </div>
              <p class="caption"><b>Figure&nbsp;9 &mdash; Self-contained example</b></p>
            </div>
          </div>
        </div>
        <div class="section"><a id="id3057351212L" name="id3057351212L"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">13 </span>Comprehensive examples</h1>
          </div>
          <p>This section contains a set of examples that transcend the boundaries
  of individual topics. These examples combine multiple different techniques
  and often address more common use-cases found "in the wild".</p>
          <div class="section"><a id="id3057357612L" name="id3057357612L"></a>
            <div>
              <h2 class="title"><span class="section-number">13.1 </span>Transforming DocBook using the DocBook XSL stylesheets</h2>
            </div>
            <p>In the XML universe, one common use-case is converting <a href="http://www.docbook.org/">DocBook</a> (a common XML application)
    to various output formats for publishing using the <a href="http://docbook.sourceforge.net/projects/xsl/index.html">DocBook
    XSL</a> set of XSLT scripts. If you have the DocBook XSL distribution
    installed (or if you have an Internet connection), you can transform
    DocBook files completely within the 4Suite XML API. The following example
    illustrates how this can be done, and in the process this example touches
    on a wide variety of 4Suite XML techniques. These are listed below.</p>
            <ul style="list-style-type: disc; list-style-position: outside;">
              <li>
                <p>Building a Domlette XML model manually</p>
              </li>
              <li>
                <p>Parsing XML into a Domlette XML model</p>
              </li>
              <li>
                <p>Using XSLT in 4Suite XML</p>
              </li>
              <li>
                <p>Using <tt class="classname">InputSource</tt>s with automatic XML
        Catalog resolution</p>
              </li>
              <li>
                <p>Managing URIs</p>
              </li>
              <li>
                <p>Writing XML from a Domlette XML model</p>
              </li>
              <li>
                <p>And a bonus feature unrelated to 4Suite: i18n with the DocBook
        XSL scripts!</p>
              </li>
            </ul>
            <div class="programlisting">
              <pre>from Ft.Xml.Domlette import implementation, PrettyPrint, NonvalidatingReader
from Ft.Xml.Xslt import Processor
from Ft.Xml import Catalog, InputSource, EMPTY_NAMESPACE
from Ft.Lib import Uri, UriException

# New processor
processor = Processor.Processor()

# If you have the DocBook XSL scripts installed in your system, then they are likely
# integrated into the system catalog, which is often at `/etc/xml/catalog` on
# Unix-like systems.  If you have a catalog which resolves the DocBook XSL URIs
# located in a different filename, you can change this filename below.  Otherwise,
# this example will access the DocBook XSL scripts directly (i.e. over the network).
catalog_filename = '/etc/xml/catalog'
# Turn the catalog filename into the corresponding `file` URI.
catalog_URI = Uri.OsPathToUri(catalog_filename)
# Try to load the catalog, moving right along if it doesn't exist.
theCatalog = None
try:
  theCatalog = Catalog.Catalog(catalog_URI)
except UriException, e:
  pass

# Create a new `InputSourceFactory` object to use our catalog.
inputSourceFactory = InputSource.InputSourceFactory(catalog = theCatalog)
docbook_xsl_URI = 'http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl'
# Set up an `InputSource` for the DocBook XSL stylesheets.
docbook_xsl_source = inputSourceFactory.fromUri(docbook_xsl_URI)
# Build a DOM of our stylesheet, then load the stylesheet into the XSLT processor.
transform = NonvalidatingReader.parse(docbook_xsl_source)
processor.appendStylesheetNode(transform, docbook_xsl_URI)

# Now we build our DocBook DOM, with a document root of myDoc.
myDoc = implementation.createRootNode('file:///article.xml')
article = myDoc.createElementNS(EMPTY_NAMESPACE,  'article')
myDoc.appendChild(article)
article.setAttributeNS(None, 'lang', "es")
myDoc.publicId="-//OASIS//DTD DocBook XML V4.2//EN"
myDoc.systemId="http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"

element = myDoc.createElementNS(EMPTY_NAMESPACE, 'title')
element.appendChild(myDoc.createTextNode('Title of article'))
article.appendChild(element)

section = myDoc.createElementNS(EMPTY_NAMESPACE, 'section')
article.appendChild(section)

element = myDoc.createElementNS(EMPTY_NAMESPACE, 'title')
element.appendChild(myDoc.createTextNode('Title of section'))
section.appendChild(element)

element = myDoc.createElementNS(EMPTY_NAMESPACE, 'para')
element.appendChild(myDoc.createTextNode('paragraph of section'))
section.appendChild(element)

print '************************ xml *******************************'
# Serialize the source document as XML.
PrettyPrint(myDoc)

print '************************ html *******************************'
# Print the result of transforming the document.
result = processor.runNode(myDoc)
print result</pre>
            </div>
          </div>
        </div>
        <div class="section"><a id="id3057360108L" name="id3057360108L"></a>
          <div class="section-title">
            <h1 class="title"><span class="section-number">14 </span>Resources</h1>
          </div>
          <p>Sources of additional information</p>
          <p>More on DOMs in Python: <a href="http://uche.ogbuji.net/tech/akara/nodes/2003-01-01/dom">Basic DOM
  processing</a></p>
          <p><a href="http://uche.ogbuji.net/tech/akara/nodes/2004-06-12/external-encoding">External
  encoding declarations</a></p>
          <p>[XML
  Catalogs|http://uche.ogbuji.net/tech/akara/nodes/2004-06-12/external-encoding]</p>
          <p>There is more coverage of the 4Suite XPath package in this <a href="http://www.xml.com/pub/a/2002/10/16/py-xml.html">Tour of
  4Suite</a>.</p>
          <p><a href="http://www.logilab.org/XMLTutorial/diap60.html">This slide
  and the following</a> from Alexandre Fayolles' excellent <a href="http://www.logilab.org/XMLTutorial/">EuroPython 2002 tutorial on
  Python/XML processing</a> is an great introduction to XPath and XSLT
  processing in Python.</p>
          <p>This <a href="http://www-105.ibm.com/developerworks/education.nsf/xml-onlinecourse-bytitle/BE1A7E60838F9F7686256AF400523C58">XPath
  and 4XPath tutorial</a> is a bit dated, but very comprehensive. Free
  registration is required.</p>
          <p>You can use EXSLT's node-set extension to provide functionality much
  like transform chaining. FOr more details see <a href="http://www-128.ibm.com/developerworks/xml/library/x-tipxsltmp.html">"Tip:
  Multi-pass XSLT"</a></p>
          <p>For more on RELAX NG in general, see <a href="http://www.oasis-open.org/committees/relax-ng/tutorial-20011203.html">The
  official RELAX NG tutorial</a>.</p>
          <p>For more on XVIF, see this <a href="http://lists.fourthought.com/pipermail/4suite/2002-October/004442.html">follow-up
  by Eric</a>.</p>
          <p>I use 4xml's --rng option in examples in <a href="http://www-106.ibm.com/developerworks/xml/library/x-xmptron/">my
  article on Examplotron</a></p>
          <p>If you want to try out online 4suite and RelaxNG, go to <a href="http://www.defuze.org/oss/tree/">http://www.defuze.org/oss/tree/</a></p>
          <p><a href="http://www.xml.com/pub/a/2005/04/20/py-xml.html">This
  article</a> discusses MarkupWriter</p>
          <p>For more examples of MarkupWriter, see:</p>
          <ul style="list-style-type: disc; list-style-position: outside;">
            <li>
              <p><a href="http://copia.ogbuji.net/blog/2005-08-01/Another_sm">"Another small
      4Suite MarkupWriter example: XHTML 1.1"</a></p>
            </li>
            <li>
              <p><a href="http://copia.ogbuji.net/blog/2005-05-09/XML_recurs">"XML recursive
      directory listing, part 2"</a></p>
            </li>
          </ul>
          <p>See <a href="http://uche.ogbuji.net/tech/akara/?xslt=irc.xslt&amp;date=2003-05-28#00:05:17">this
  #4suite blog entry</a> for another example of XPath extensions.</p>
          <p>Tamito KAJIYAMA responds to a thread discussing the grouped sorting
  XSLT FAQ in 4XSLT, <a href="http://mail.python.org/pipermail/xml-sig/2003-May/009430.html">offering
  an extension function as a possible solution</a>.</p>
        </div>
      </div>
    </div>
  </body>
</html>
